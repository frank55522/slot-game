# 題目一技術實作指南：中獎連線顯示功能

## 實作目標
在老虎機遊戲中實現中獎連線顯示功能，當玩家中獎時自動顯示連線結果（如「M1 × 5」）。

## 整體架構思路

### 1. 核心流程設計
```
遊戲轉動 → 伺服器回傳結果 → 解析中獎數據 → 顯示中獎信息
     ↓              ↓              ↓              ↓
   玩家操作    GAME_ParseState    PureMVC通知    HTML覆蓋層
              WinResultCommand    機制          顯示
```

### 2. MVC架構應用
- **Model**：中獎數據 (WAY_WinInfo)
- **View**：HTML覆蓋層顯示
- **Controller**：WinLineDisplayMediator

## 詳細實作步驟

### 步驟1：找到數據處理入口點

**目標**：找到遊戲處理中獎結果的地方

**方法**：
1. 搜尋專案中與「Win」、「Result」相關的文件
2. 找到 `GAME_ParseStateWinResultCommand.ts`
3. 這個文件負責解析伺服器回傳的遊戲結果

**關鍵代碼位置**：
```typescript
// GAME_ParseStateWinResultCommand.ts 第52-53行
this.triggerWinLineDisplay(); // 我們要修改的地方
```

### 步驟2：理解數據結構

**中獎數據格式 (WAY_WinInfo)**：
```typescript
{
    symbolId: number,     // 符號ID (0=WILD, 2=M1, 6=Q, 7=K等)
    hitCount: number,     // 連線數量
    symbolWin: number,    // 中獎金額
    hitOdds: number,      // 賠率
    hitNumber: number     // 連線編號
}
```

**實際數據範例**：
```typescript
[
    { symbolId: 3, hitCount: 4, symbolWin: 3.00 },  // M2 × 4 = 3.00
    { symbolId: 6, hitCount: 3, symbolWin: 1.50 }   // Q × 3 = 1.50
]
```

### 步驟3：實現數據攔截和Console輸出

**在 `GAME_ParseStateWinResultCommand.ts` 中修改**：

```typescript
private triggerWinLineDisplay() {
    if (this.gameDataProxy.stateWinData.wayInfos.length > 0) {
        // 過濾有效中獎 (symbolWin > 0)
        const validWinInfos = this.gameDataProxy.stateWinData.wayInfos
            .filter(info => info.symbolWin > 0);
        
        if (validWinInfos.length > 0) {
            // === Console輸出實現 ===
            console.log('=== 本局中獎連線結果 ===');
            validWinInfos.forEach((winInfo) => {
                const symbolName = this.getSymbolNameById(winInfo.symbolId);
                console.log(`${symbolName} × ${winInfo.hitCount} = ${winInfo.symbolWin.toFixed(2)}`);
            });
            console.log(`總共 ${validWinInfos.length} 條中獎連線`);
            
            // 發送PureMVC通知觸發UI顯示
            this.sendNotification('SHOW_WIN_LINES', validWinInfos);
        }
    }
}

// 符號ID轉換函數
private getSymbolNameById(symbolId: number): string {
    const symbolMap = {
        0: 'WILD', 1: 'C1', 2: 'M1', 3: 'M2', 4: 'M3',
        5: 'J', 6: 'Q', 7: 'K', 8: 'A', 9: '10', 10: '9'
    };
    return symbolMap[symbolId] || `Symbol_${symbolId}`;
}
```

**關鍵點解析**：
- `filter(info => info.symbolWin > 0)`：只顯示真正中獎的連線
- `getSymbolNameById()`：將數字ID轉為可讀的符號名稱
- `sendNotification()`：發送PureMVC事件觸發UI顯示

### 步驟4：實現UI顯示邏輯

**創建 `WinLineDisplayMediator.ts`**：

```typescript
import { _decorator } from 'cc';
import BaseMediator from '../../base/BaseMediator';

@ccclass('WinLineDisplayMediator')
export class WinLineDisplayMediator extends BaseMediator<any> {
    public static NAME: string = 'WinLineDisplayMediator';
    private htmlOverlay: HTMLElement | null = null;

    // 監聽的PureMVC事件
    public listNotificationInterests(): Array<any> {
        return ['SHOW_WIN_LINES', 'HIDE_WIN_LINES'];
    }

    // 處理事件通知
    public handleNotification(notification: puremvc.INotification): void {
        switch (notification.getName()) {
            case 'SHOW_WIN_LINES':
                this.showHTMLWinText(notification.getBody());
                break;
            case 'HIDE_WIN_LINES':
                this.hideHTMLWinText();
                break;
        }
    }

    // HTML覆蓋層實現
    private showHTMLWinText(winData: any[]) {
        // 組合顯示文字
        const winTexts = winData.map((win) => {
            const symbolName = this.getSymbolNameById(win.symbolId);
            return `${symbolName} × ${win.hitCount} = ${win.symbolWin.toFixed(2)}`;
        });
        
        // 創建HTML元素
        this.htmlOverlay = document.createElement('div');
        this.htmlOverlay.style.cssText = `
            position: fixed;           /* 固定位置，不受頁面滾動影響 */
            top: 50%; left: 50%;      /* 螢幕中央 */
            transform: translate(-50%, -50%);  /* 精確置中 */
            background: rgba(0, 0, 0, 0.8);   /* 半透明黑底 */
            color: #FFD700;           /* 金色文字 */
            font-size: 32px;          /* 大字體 */
            font-weight: bold;        /* 粗體 */
            text-align: center;       /* 文字置中 */
            padding: 30px;            /* 內邊距 */
            border-radius: 15px;      /* 圓角 */
            border: 3px solid #FFD700; /* 金色邊框 */
            z-index: 10000;           /* 最高層級，確保顯示在最上方 */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);  /* 文字陰影 */
            box-shadow: 0 0 20px rgba(255,215,0,0.6);  /* 發光效果 */
        `;
        
        // 設置顯示內容
        this.htmlOverlay.innerHTML = `🎉 中獎連線 🎉<br>${winTexts.join('<br>')}`;
        
        // 添加到頁面
        document.body.appendChild(this.htmlOverlay);
        
        // 3秒後自動隱藏
        setTimeout(() => this.hideHTMLWinText(), 3000);
    }
}
```

### 步驟5：系統整合

**創建 `WinLineTestTrigger.ts`**：

```typescript
@ccclass('WinLineTestTrigger')
export class WinLineTestTrigger extends Component {
    onLoad() {
        // 延遲2秒等待遊戲系統初始化
        setTimeout(() => this.initialize(), 2000);
    }

    private initialize() {
        // 註冊Mediator到PureMVC系統
        this.registerWinLineMediator();
        
        // 提供測試函數
        this.exposeTestFunctions();
    }

    private registerWinLineMediator() {
        const facade = puremvc.Facade.getInstance();
        const mediator = new WinLineDisplayMediator();
        facade.registerMediator(mediator);
    }
}
```

## 技術難點與解決方案

### 難點1：Cocos Creator UI渲染問題

**問題**：純程式碼創建的UI組件無法顯示

**原因分析**：
- Cocos Creator通常使用Prefab管理UI
- 渲染層級複雜，程式碼創建的組件可能被遮蓋
- Canvas設置和相機層級影響顯示

**解決方案**：HTML覆蓋層
```typescript
// 關鍵CSS屬性
position: fixed;     // 脫離文檔流，固定位置
z-index: 10000;     // 最高層級
transform: translate(-50%, -50%);  // 精確置中
```

### 難點2：PureMVC架構整合

**理解要點**：
- **Command**：處理業務邏輯 (ParseStateWinResultCommand)
- **Mediator**：管理UI顯示 (WinLineDisplayMediator)  
- **Notification**：組件間通訊機制

**通訊流程**：
```
Command.sendNotification() → Facade → Mediator.handleNotification()
```

### 難點3：數據格式轉換

**挑戰**：將遊戲內部的數字ID轉為玩家可讀的符號

**實現**：映射表 + 函數封裝
```typescript
const symbolMap = {
    0: 'WILD', 2: 'M1', 6: 'Q', 7: 'K'
    // ...更多映射
};
```

## 測試與驗證

### 自動測試
1. 啟動遊戲
2. 進行轉動操作
3. 中獎時觀察Console和畫面顯示

### 手動測試
```javascript
// 瀏覽器Console執行
testWinLineDisplay()  // 模擬中獎顯示
```

## 擴展思路

### 可能的改進方向
1. **動畫效果**：添加淡入淡出、縮放動畫
2. **音效整合**：中獎時播放音效
3. **多語言支持**：根據遊戲語言顯示不同文字
4. **自定義樣式**：允許玩家自定義顯示樣式

### 架構優化
1. **配置文件**：將符號映射表移到配置文件
2. **事件解耦**：使用更細粒度的事件系統
3. **錯誤處理**：添加容錯機制

## 總結

這個實作展示了幾個重要的開發思路：

1. **由簡到繁**：先實現Console輸出，再處理UI顯示
2. **架構理解**：深入理解現有系統的設計模式
3. **創新解決**：當傳統方法遇到困難時，採用創新方案
4. **代碼品質**：最終清理冗餘，保持結構清潔

通過這個專案，不僅完成了功能需求，更重要的是學習了遊戲開發中的架構設計和問題解決思維。