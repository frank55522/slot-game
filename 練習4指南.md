# H5_Slot_練習4 簡報指南

## 題目一：GameLogo Bundle 載入與顯示

### 🎯 核心重點
1. **preload階段載入** gameLogo Bundle
2. **多語系顯示** 依照語系自動切換Logo圖片
3. **點擊/自動關閉** 3秒自動關閉或點擊任何位置關閉
4. **流程控制** Logo關閉後才能進入遊戲

### 📁 資源結構
```
assets/prefabs/gameLogo/GameLogo.prefab
assets/art/language/{en,zh,th}/intro/GameLogo.png
```

### 💡 關鍵技術
- **Bundle載入時機**：在`setLoadList()`的baseLoad中載入
- **多語系支援**：使用`LocalizedSprite`組件自動切換
- **圖層管理**：使用`LayerManager.setLayer(999)`確保最上層顯示
- **輸入處理**：全域輸入監聽支援滑鼠+觸控

---

## 🔧 核心程式碼

### 1. Bundle載入配置
`LoadingViewMediator.ts:167-172`
```typescript
{
    status: LoadStatus.NONE,
    info: { bundleName: 'gameLogo', assetName: 'GameLogo' },
    onTaskFinished: (prefab: Prefab) => {
        this.gameLogoPrefab = prefab;
}
```

### 2. 屬性定義
`LoadingViewMediator.ts:391-394`
```typescript
private gameLogoPrefab: Prefab | null = null;
private gameLogoNode: Node | null = null;
private logoCloseTimer: number = 0;
private canEnterGame: boolean = false;
```

### 3. 顯示時機控制
`LoadingViewMediator.ts:181-196`
```typescript
protected delayEnterLobby(): void {
    if (this.gameLogoPrefab && !this.gameLogoNode) {
        this.showGameLogo(this.gameLogoPrefab);
        return;
    }
    if (!this.canEnterGame) {
        return;
    }
    this.enterGameAfterLogo();
}
```

### 4. Logo顯示與輸入處理
`LoadingViewMediator.ts:399-416`
```typescript
private showGameLogo(prefab: Prefab) {
    this.gameLogoNode = instantiate(prefab);
    director.getScene().addChild(this.gameLogoNode);

    const dummyComponent = this.gameLogoNode.addComponent(Component);
    LayerManager.setLayer(dummyComponent, 999);

    this.startInputListening();

    this.logoCloseTimer = window.setTimeout(() => {
        this.closeGameLogo();
    }, 3000);
}
```

### 5. 關閉處理
`LoadingViewMediator.ts:440-465`
```typescript
private closeGameLogo() {
    if (this.gameLogoNode) {
        clearTimeout(this.logoCloseTimer);
        this.stopInputListening();
        this.gameLogoNode.destroy();
        this.gameLogoNode = null;
        this.canEnterGame = true;

        if (this.isInitData) {
            this.enterGameAfterLogo();
        }
    }
}
```

---

## 題目二：Symbol 動畫實作

### 🎯 核心重點
1. **統一動畫效果** 所有symbol中獎時都播放放大2倍再縮小回1倍的動畫
2. **使用TimelineTool** 採用專案原有的TimelineTool系統實作
3. **AllWin和LoopWin統一** 兩個表演階段使用相同動畫
4. **擴展性佳** 任何symbol只要配置TimelineTool都能有動畫效果

### 💡 關鍵技術
- **TimelineTool系統**：使用專案原有的動畫框架
- **繼承架構**：繼承SymbolAllWinState和SymbolLoopWinState
- **Cocos Creator Animation**：在Main節點配置縮放動畫
- **動畫統一管理**：使用相同的'ScaleEffect'動畫名稱

---

## 🔧 核心程式碼

### 1. SymbolContent添加TimelineTool支援
`Game_1_SymbolContent.ts`
```typescript
import { TimelineTool } from 'TimelineTool';

@ccclass('Game_1_SymbolContent')
export class Game_1_SymbolContent extends SymbolContentBase {
    // ... 其他屬性
    @property({ type: TimelineTool, visible: true })
    public timelineTool: TimelineTool | null = null;
}
```

### 2. 創建繼承的State類別
`Game_1_SymbolStateRegister.ts`
```typescript
export class Game_1_SymbolAllWinState extends SymbolAllWinState {
    private content: Game_1_SymbolContent | null = null;

    constructor(content: Game_1_SymbolContent) {
        super(content);
        this.content = content;
    }

    onPlay() {
        // 如果有TimelineTool，則播放統一的縮放動畫
        if (this.content.timelineTool) {
            this.content.timelineTool.play('ScaleEffect', () => {
                this.onEffectFinished();
            });
        } else {
            // 沒有TimelineTool使用原有邏輯
            super.onPlay();
        }
    }

    onStop() {
        if (this.content.timelineTool) {
            this.content.timelineTool.stop();
            this.onEffectFinished(true);
        } else {
            super.onStop();
        }
    }

    onSkip() {
        if (this.content.timelineTool) {
            this.content.timelineTool.stop();
            this.onEffectFinished(true);
        } else {
            super.onSkip();
        }
    }
}

export class Game_1_SymbolLoopWinState extends SymbolLoopWinState {
    // 相同的實作邏輯，使用統一的'ScaleEffect'動畫
}
```

### 3. 註冊新的State類別
```typescript
onRegister() {
    super.onRegister();
    // ... 其他註冊
    this.registerState(new Game_1_SymbolAllWinState(this.content));
    this.registerState(new Game_1_SymbolLoopWinState(this.content));
}
```

### 4. 重要Bug修正：Scale重置
**問題**：動畫結束後spin新的一輪，symbol可能保持放大狀態

**解決方案**：在關鍵State中重置scale
```typescript
// 在Game_1_SymbolShowState和Game_1_RollCycledState的onPlay()中添加
// 確保Main節點縮放重置為1
if (this.content.mainSprite) {
    this.content.mainSprite.node.scale = new Vec3(1, 1, 1);
}
```

**修改檔案**：
- `Game_1_SymbolShowState.onPlay()`：symbol顯示時重置
- `Game_1_RollCycledState.onPlay()`：轉軸循環時重置

---

## 🎨 Cocos Creator配置

### 1. Game_1_Symbol Prefab配置
1. **在根節點添加TimelineTool組件**
2. **在Main節點添加Animation組件**
3. **創建AnimationClip名為'ScaleEffect'**：
   - 0.0秒：scale (1, 1, 1)
   - 0.3秒：scale (2, 2, 1)
   - 0.6秒：scale (1, 1, 1)

### 2. TimelineTool配置
1. **創建Timeline**：名稱設為'ScaleEffect'
2. **Timeline Type**：選擇Animation
3. **連接Animation組件**：將Main節點的Animation拖入
4. **連接到SymbolContent**：將TimelineTool拖入timelineTool欄位

### 3. 動畫效果
- **動畫時長**：0.6秒
- **縮放效果**：1倍 → 2倍 → 1倍
- **適用範圍**：所有配置了TimelineTool的symbol
- **表演階段**：AllWin和LoopWin都使用相同動畫

---

## ✅ 實作完成檢查
1. **動畫播放**：symbol中獎時正確播放縮放動畫
2. **統一效果**：AllWin和LoopWin階段使用相同動畫
3. **架構一致**：使用專案原有的TimelineTool系統
4. **連接正確**：timelineTool屬性正確連接到TimelineTool組件
5. **Scale重置**：新spin時所有symbol都回到正常大小
6. **無副作用**：不影響沒有配置TimelineTool的symbol

## 🐛 常見問題排除

### 問題1：TimelineTool動畫不播放
**症狀**：symbol中獎但沒有縮放動畫
**解決**：檢查timelineTool屬性是否正確連接到TimelineTool組件

### 問題2：Spin後symbol保持放大狀態
**症狀**：動畫播放後，新一輪spin時部分symbol顯示放大
**解決**：在Game_1_SymbolShowState和Game_1_RollCycledState中添加scale重置

### 問題3：動畫節奏不連續
**症狀**：多種symbol輪流表演時有"等一拍"的感覺
**說明**：這是正常現象，不同symbol的表演時間不同造成的節奏變化