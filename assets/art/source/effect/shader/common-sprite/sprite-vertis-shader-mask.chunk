  precision highp float;
  #include <transform>
  #include <particle-common>

  #include <cc-global>
  in vec3 a_position; // center position
  in vec3 a_texCoord;  // xy:vertex index,z:frame index
  in vec3 a_texCoord1; // size
  in vec3 a_texCoord2; // rotation
  in vec4 a_color;
  out vec2 m_uv;
  out vec2 smooth_mask_uv;
  out vec2 noise_uv;
  out vec2 d_uv;
  
  uniform TexCoords {
    float main_Rotation;
    float main_UV_Move_Z_Time;
    float main_UV_Move_W_Time;
    float smooth_UV_Edge;
    float add_intensity;
  };
  #if mask_Map
    uniform MaskTexCoords {
      vec4 mask_tilingOffset;
      float mask_Rotation;
      float maskAlphaValue;
      float mask_UV_Move_Z_Time;
      float mask_UV_Move_W_Time;
    };
  #endif
  #if dissolve_Map
    uniform dissolveTexCoords {
      vec4 dissolve_tilingOffset;
      float dissolve_Rotation;
      //float maskAlphaValue;
      //float mask_UV_Move_Time;
    };
  #endif
  #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
    in vec3 a_color1; // velocity.x, velocity.y, velocity.z, scale
  #endif

  #if CC_RENDER_MODE == RENDER_MODE_MESH
    in vec3 a_texCoord3;  // mesh vertices
    in vec3 a_normal;     // mesh normal
    in vec4 a_color1;     // mesh color
  #endif

  vec4 vert () {
    vec3 compScale = scale.xyz * a_texCoord1;
    vec4 pos = vec4(a_position, 1);
    #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
      vec4 velocity = vec4(a_color1.xyz, 0);
    #endif

    #if !CC_USE_WORLD_SPACE
      // simulate in world space. apply cc_matWorld matrix on CPU side.
      pos = cc_matWorld * pos;
      #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
        velocity = cc_matWorld * velocity;
      #endif
    #endif

    #if CC_RENDER_MODE != RENDER_MODE_MESH
      vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));

      #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD
        vec3 rotEuler = a_texCoord2;
      #elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
        vec3 rotEuler = vec3(0.);
      #else
        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);
      #endif

      computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale
      #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD || CC_RENDER_MODE == RENDER_MODE_VERTICAL_BILLBOARD
        , cc_matViewInv
      #endif
      #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
        , cc_cameraPos.xyz
        , velocity
        , frameTile_velLenScale.z
        , frameTile_velLenScale.w
        , a_texCoord.x
      #endif
      );

      color = a_color;
    #else
      mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);
      mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);
      pos = xform * vec4(a_texCoord3, 1);
      vec4 normal = xformNoScale * vec4(a_normal, 0);
      color = a_color * a_color1;
    #endif
    
    uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy;
    uv.y += (mainTiling_Offset.z - (cc_time.x * main_UV_Move_Z_Time));
    uv.x += (mainTiling_Offset.w - (cc_time.x * main_UV_Move_W_Time));
    smooth_mask_uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy);
    noise_uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy);
    // uv rotation
    float rotation =  main_Rotation * 3.14159265359 / 180.0 ;
    uv = vec2(cos(rotation) * (uv.x - 0.5) - sin(rotation) * (uv.y - 0.5) + 0.5,
              sin(rotation) * (uv.x - 0.5) + cos(rotation) * (uv.y - 0.5) + 0.5 );

    #if mask_Map
    m_uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mask_tilingOffset.xy;
    m_uv.y += (mask_tilingOffset.z + (cc_time.x * mask_UV_Move_Z_Time));
    m_uv.x += (mask_tilingOffset.w + (cc_time.x * mask_UV_Move_W_Time));
    rotation =  mask_Rotation * 3.14159265359 / 180.0 ;
    m_uv = vec2(cos(rotation) * (m_uv.x - 0.5) - sin(rotation) * (m_uv.y - 0.5) + 0.5,
                sin(rotation) * (m_uv.x - 0.5) + cos(rotation) * (m_uv.y - 0.5) + 0.5 );
    #endif  

    #if dissolve_Map
    d_uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * dissolve_tilingOffset.xy ;
    d_uv.y += dissolve_tilingOffset.z; 
    d_uv.x += dissolve_tilingOffset.w;
    rotation =  dissolve_Rotation * 3.14159265359 / 180.0 ;
    d_uv = vec2(cos(rotation) * (d_uv.x - 0.5) - sin(rotation) * (d_uv.y - 0.5) + 0.5,
                sin(rotation) * (d_uv.x - 0.5) + cos(rotation) * (d_uv.y - 0.5) + 0.5 );
    #endif                      
    pos = cc_matViewProj * pos;

    return pos;
}