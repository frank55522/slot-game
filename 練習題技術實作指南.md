# 練習題技術實作指南：老虎機遊戲增強功能

## 實作目標

### 題目一：中獎連線顯示功能
在老虎機遊戲中實現中獎連線顯示功能，當玩家中獎時自動顯示連線結果（如「M1 × 5」）。

### 題目二：Show Win 動畫效果
在 show win 時透過 TimelineTool 播放動畫，為中獎連線顯示增加視覺效果。

### 題目三：BaseGame 贏分龍珠顯示
定義一個事件在 BaseGame 滾停後發出，事件帶有贏分參數，讓上方大龍珠顯示當局贏分。

### 題目四：倒數五秒狀態
在game1 spin和roll complete之間新增一個倒數五秒的狀態，會在畫面上倒數5秒再繼續後續流程。

---

## 整體架構思路

### 1. 核心流程設計
```
遊戲轉動 → 伺服器回傳結果 → 解析中獎數據 → 顯示中獎信息 + 播放動畫 + 龍珠顯示贏分
     ↓              ↓              ↓              ↓              ↓
   玩家操作    GAME_ParseState    PureMVC通知    HTML覆蓋層    上方大龍珠
              WinResultCommand    機制          + CSS動畫     + 自動清除
```

### 2. MVC架構應用
- **Model**：中獎數據 (WAY_WinInfo) + BaseGame 贏分數據
- **View**：HTML覆蓋層顯示 + 動畫效果 + 大龍珠顯示
- **Controller**：WinLineDisplayMediator + BallHitViewMediator

---

## 題目一：中獎連線顯示功能

### 詳細實作步驟

#### 步驟1：找到數據處理入口點

**目標**：找到遊戲處理中獎結果的地方

**方法**：
1. 搜尋專案中與「Win」、「Result」相關的文件
2. 找到 `GAME_ParseStateWinResultCommand.ts`
3. 這個文件負責解析伺服器回傳的遊戲結果

**關鍵代碼位置**：
```typescript
// GAME_ParseStateWinResultCommand.ts 第52-53行
this.triggerWinLineDisplay(); // 我們要修改的地方
```

#### 步驟2：理解數據結構

**中獎數據格式 (WAY_WinInfo)**：
```typescript
{
    symbolId: number,     // 符號ID (0=WILD, 2=M1, 6=Q, 7=K等)
    hitCount: number,     // 連線數量
    symbolWin: number,    // 中獎金額
    hitOdds: number,      // 賠率
    hitNumber: number     // 連線編號
}
```

**實際數據範例**：
```typescript
[
    { symbolId: 3, hitCount: 4, symbolWin: 3.00 },  // M2 × 4 = 3.00
    { symbolId: 6, hitCount: 3, symbolWin: 1.50 }   // Q × 3 = 1.50
]
```

#### 步驟3：實現數據攔截和Console輸出

**在 `GAME_ParseStateWinResultCommand.ts` 中修改**：

```typescript
private triggerWinLineDisplay() {
    if (this.gameDataProxy.stateWinData.wayInfos.length > 0) {
        // 過濾有效中獎 (symbolWin > 0)
        const validWinInfos = this.gameDataProxy.stateWinData.wayInfos
            .filter(info => info.symbolWin > 0);
        
        if (validWinInfos.length > 0) {
            // === Console輸出實現 ===
            console.log('=== 本局中獎連線結果 ===');
            validWinInfos.forEach((winInfo) => {
                const symbolName = this.getSymbolNameById(winInfo.symbolId);
                console.log(`${symbolName} × ${winInfo.hitCount} = ${winInfo.symbolWin.toFixed(2)}`);
            });
            console.log(`總共 ${validWinInfos.length} 條中獎連線`);
            
            // 發送PureMVC通知觸發UI顯示
            this.sendNotification('SHOW_WIN_LINES', validWinInfos);
        }
    }
}

// 符號ID轉換函數
private getSymbolNameById(symbolId: number): string {
    const symbolMap = {
        0: 'WILD', 1: 'C1', 2: 'M1', 3: 'M2', 4: 'M3',
        5: 'J', 6: 'Q', 7: 'K', 8: 'A', 9: '10', 10: '9'
    };
    return symbolMap[symbolId] || `Symbol_${symbolId}`;
}
```

**關鍵點解析**：
- `filter(info => info.symbolWin > 0)`：只顯示真正中獎的連線
- `getSymbolNameById()`：將數字ID轉為可讀的符號名稱
- `sendNotification()`：發送PureMVC事件觸發UI顯示

#### 步驟4：實現UI顯示邏輯

**創建 `WinLineDisplayMediator.ts`**：

```typescript
import { _decorator } from 'cc';
import BaseMediator from '../../base/BaseMediator';

@ccclass('WinLineDisplayMediator')
export class WinLineDisplayMediator extends BaseMediator<any> {
    public static NAME: string = 'WinLineDisplayMediator';
    private htmlOverlay: HTMLElement | null = null;

    // 監聽的PureMVC事件
    public listNotificationInterests(): Array<any> {
        return ['SHOW_WIN_LINES', 'HIDE_WIN_LINES'];
    }

    // 處理事件通知
    public handleNotification(notification: puremvc.INotification): void {
        switch (notification.getName()) {
            case 'SHOW_WIN_LINES':
                this.showHTMLWinText(notification.getBody());
                break;
            case 'HIDE_WIN_LINES':
                this.hideHTMLWinText();
                break;
        }
    }

    // HTML覆蓋層實現
    private showHTMLWinText(winData: any[]) {
        // 組合顯示文字
        const winTexts = winData.map((win) => {
            const symbolName = this.getSymbolNameById(win.symbolId);
            return `${symbolName} × ${win.hitCount} = ${win.symbolWin.toFixed(2)}`;
        });
        
        // 創建HTML元素
        this.htmlOverlay = document.createElement('div');
        this.htmlOverlay.style.cssText = `
            position: fixed;           /* 固定位置，不受頁面滾動影響 */
            top: 50%; left: 50%;      /* 螢幕中央 */
            transform: translate(-50%, -50%);  /* 精確置中 */
            background: rgba(0, 0, 0, 0.8);   /* 半透明黑底 */
            color: #FFD700;           /* 金色文字 */
            font-size: 32px;          /* 大字體 */
            font-weight: bold;        /* 粗體 */
            text-align: center;       /* 文字置中 */
            padding: 30px;            /* 內邊距 */
            border-radius: 15px;      /* 圓角 */
            border: 3px solid #FFD700; /* 金色邊框 */
            z-index: 10000;           /* 最高層級，確保顯示在最上方 */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);  /* 文字陰影 */
            box-shadow: 0 0 20px rgba(255,215,0,0.6);  /* 發光效果 */
        `;
        
        // 設置顯示內容
        this.htmlOverlay.innerHTML = `🎉 中獎連線 🎉<br>${winTexts.join('<br>')}`;
        
        // 添加到頁面
        document.body.appendChild(this.htmlOverlay);
        
        // 3秒後自動隱藏
        setTimeout(() => this.hideHTMLWinText(), 3000);
    }
}
```

#### 步驟5：系統整合

**創建 `WinLineTestTrigger.ts`**：

```typescript
@ccclass('WinLineTestTrigger')
export class WinLineTestTrigger extends Component {
    onLoad() {
        // 延遲2秒等待遊戲系統初始化
        setTimeout(() => this.initialize(), 2000);
    }

    private initialize() {
        // 註冊Mediator到PureMVC系統
        this.registerWinLineMediator();
        
        // 提供測試函數
        this.exposeTestFunctions();
    }

    private registerWinLineMediator() {
        const facade = puremvc.Facade.getInstance();
        const mediator = new WinLineDisplayMediator();
        facade.registerMediator(mediator);
    }
}
```

---

## 題目二：Show Win 動畫效果

### 實作概念

基於題目一的 HTML 覆蓋層，透過 CSS 動畫實現視覺效果，讓中獎顯示更加顯眼和吸引人。

### 動畫設計思路

#### 1. 持續動畫系統
- **搖擺彈跳**：模擬慶祝的興奮感
- **光暈脈衝**：營造發光效果
- **整個顯示期間持續播放**：確保視覺吸引力

#### 2. 動畫時間軸
```
出現(0.01s) → 持續動畫(3s) → 消失動畫(0.5s)
     ↓            ↓              ↓
   立即顯示   搖擺+發光       縮小淡出
```

### 實作步驟

#### 步驟1：CSS 動畫定義

**在 `WinLineDisplayMediator.ts` 中新增動畫樣式**：

```typescript
// 先添加CSS動畫定義到頁面
if (!document.getElementById('win-bounce-animation')) {
    const style = document.createElement('style');
    style.id = 'win-bounce-animation';
    style.textContent = `
        @keyframes winShake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            10% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            20% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            30% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            40% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            50% { transform: translate(-50%, -50%) rotate(0deg) scale(1.15); }
            60% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            70% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            80% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            90% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
        }
        @keyframes winGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255,215,0,0.6); }
            50% { box-shadow: 0 0 40px rgba(255,215,0,1), 0 0 60px rgba(255,215,0,0.8); }
        }
    `;
    document.head.appendChild(style);
}
```

#### 步驟2：動畫觸發邏輯

**修改顯示函數應用動畫**：

```typescript
// 立即顯示並開始持續動畫
setTimeout(() => {
    if (this.htmlOverlay) {
        // 先顯示元素
        this.htmlOverlay.style.opacity = '1';
        this.htmlOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // 開始持續的組合動畫
        this.htmlOverlay.style.animation = `
            winShake 0.8s ease-in-out infinite,
            winGlow 1.5s ease-in-out infinite
        `;
    }
}, 10);
```

#### 步驟3：視覺效果增強

**增強顯示效果**：

```typescript
this.htmlOverlay.style.cssText = `
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: rgba(0, 0, 0, 0.9);        /* 更深的背景 */
    color: #FFD700;
    font-family: Arial, sans-serif;
    font-size: 36px;                       /* 更大的字體 */
    font-weight: bold;
    text-align: center;
    padding: 40px;                         /* 更大的內邊距 */
    border-radius: 20px;                   /* 更大的圓角 */
    border: 4px solid #FFD700;             /* 更粗的邊框 */
    z-index: 10000;
    text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 10px rgba(255,215,0,0.8); /* 雙重陰影 */
    box-shadow: 0 0 20px rgba(255,215,0,0.6);
    white-space: pre-line;
    max-width: 700px;
    word-wrap: break-word;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
`;
```

#### 步驟4：消失動畫處理

**優雅的退場效果**：

```typescript
private hideHTMLWinTextWithAnimation() {
    if (this.htmlOverlay && this.htmlOverlay.parentNode) {
        console.log('[WinLineDisplayMediator] 隱藏HTML覆蓋層（帶動畫）');
        
        // 停止持續動畫，開始淡出
        this.htmlOverlay.style.animation = 'none';
        this.htmlOverlay.style.transition = 'all 0.5s ease-out';
        this.htmlOverlay.style.transform = 'translate(-50%, -50%) scale(0.5)';
        this.htmlOverlay.style.opacity = '0';
        
        // 動畫完成後移除元素
        setTimeout(() => {
            if (this.htmlOverlay && this.htmlOverlay.parentNode) {
                this.htmlOverlay.parentNode.removeChild(this.htmlOverlay);
                this.htmlOverlay = null;
            }
        }, 500);
    }
}
```

### 動畫效果說明

#### 1. **winShake 動畫**
- **效果**：輕微的旋轉搖擺 + 縮放變化
- **週期**：0.8秒一個循環
- **變化範圍**：旋轉 ±1度，縮放 1.0-1.15倍
- **目的**：模擬興奮慶祝的感覺

#### 2. **winGlow 動畫**
- **效果**：光暈強弱變化
- **週期**：1.5秒一個循環
- **變化範圍**：陰影從 20px 到 60px
- **目的**：營造發光脈衝效果

#### 3. **組合效果**
- **同時播放**：兩個動畫疊加運行
- **持續時間**：整個3秒顯示期間
- **視覺體驗**：持續的動態效果，極難忽視

---

## 技術難點與解決方案

### 難點1：Cocos Creator UI渲染問題

**問題**：純程式碼創建的UI組件無法顯示

**原因分析**：
- Cocos Creator通常使用Prefab管理UI
- 渲染層級複雜，程式碼創建的組件可能被遮蓋
- Canvas設置和相機層級影響顯示

**解決方案**：HTML覆蓋層
```typescript
// 關鍵CSS屬性
position: fixed;     // 脫離文檔流，固定位置
z-index: 10000;     // 最高層級
transform: translate(-50%, -50%);  // 精確置中
```

### 難點2：PureMVC架構整合

**理解要點**：
- **Command**：處理業務邏輯 (ParseStateWinResultCommand)
- **Mediator**：管理UI顯示 (WinLineDisplayMediator)  
- **Notification**：組件間通訊機制

**通訊流程**：
```
Command.sendNotification() → Facade → Mediator.handleNotification()
```

### 難點3：動畫性能優化

**挑戰**：CSS動畫可能影響遊戲性能

**解決策略**：
- **有限時間**：動畫只播放3秒
- **硬件加速**：使用transform屬性觸發GPU加速
- **動畫清理**：及時停止和移除動畫元素
- **輕量級動畫**：避免過於複雜的動畫效果

### 難點4：數據格式轉換

**挑戰**：將遊戲內部的數字ID轉為玩家可讀的符號

**實現**：映射表 + 函數封裝
```typescript
const symbolMap = {
    0: 'WILD', 2: 'M1', 6: 'Q', 7: 'K'
    // ...更多映射
};
```

---

## 測試與驗證

### 自動測試（推薦）
1. 啟動遊戲
2. 進行轉動操作
3. 中獎時觀察：
   - Console輸出是否正確
   - 畫面顯示是否出現
   - 動畫效果是否播放
   - 3秒後是否自動消失

### 手動測試
```javascript
// 瀏覽器Console執行
testWinLineDisplay()  // 模擬中獎顯示
hideWinLineDisplay()  // 手動隱藏測試
```

---

## 擴展思路

### 可能的改進方向

#### 功能增強
1. **多種動畫模式**：根據中獎金額使用不同動畫
2. **音效整合**：中獎時播放對應音效
3. **多語言支持**：根據遊戲語言顯示不同文字
4. **自定義樣式**：允許玩家自定義顯示樣式

#### 技術優化
1. **配置文件**：將符號映射表移到配置文件
2. **事件解耦**：使用更細粒度的事件系統
3. **錯誤處理**：添加容錯機制
4. **動畫庫**：建立可重用的動畫組件庫

### 架構優化

#### 1. 組件化設計
```typescript
// 動畫控制器
class WinAnimationController {
    static playBounceAnimation(element: HTMLElement): void
    static playGlowAnimation(element: HTMLElement): void
    static stopAllAnimations(element: HTMLElement): void
}
```

#### 2. 配置驅動
```typescript
// 動畫配置
interface AnimationConfig {
    duration: number;
    easing: string;
    effects: AnimationEffect[];
}
```

---

## 題目三：BaseGame 贏分龍珠顯示

### 實作概念

透過遊戲的 PureMVC 事件系統，在 BaseGame 滾停後發送贏分事件，讓畫面上方的大龍珠顯示當局贏分，並在下次 spin 時自動清除。

### 核心設計思路

#### 1. 事件驅動架構
```
BaseGame滾停 → 計算贏分 → 發送事件 → 龍珠顯示 → 下次spin清除
     ↓           ↓         ↓         ↓         ↓
  滾軸停止   贏分>0判斷  PureMVC通知  setBallCredit  hideBallCredit
```

#### 2. 組件分工
- **Command**：`GAME_Game1RollCompleteCommand` - 負責事件觸發
- **Event**：`DragonUpEvent.ON_BASEGAME_WIN_DISPLAY` - 事件常數
- **Mediator**：`BallHitViewMediator` - 負責UI控制
- **View**：`BallHitView` - 龍珠顯示組件

### 詳細實作步驟

#### 步驟1：定義事件常數

**在 `Constant.ts` 中新增事件**：

```typescript
export class DragonUpEvent {
    // 現有事件...
    
    /** BaseGame 滾停後顯示贏分在龍珠上 */
    public static ON_BASEGAME_WIN_DISPLAY: string = 'onBaseGameWinDisplay';
}
```

**關鍵要點**：
- 使用現有的 `DragonUpEvent` 類別，保持事件分類一致
- 事件名稱清楚表達功能目的

#### 步驟2：實作事件觸發邏輯

**在 `GAME_Game1RollCompleteCommand.ts` 中修改**：

```typescript
import { ViewMediatorEvent, DragonUpEvent } from 'src/sgv3/util/Constant';

export class GAME_Game1RollCompleteCommand extends Game1RollCompleteCommand {
    public execute(notification: puremvc.INotification): void {
        // 現有邏輯...
        
        // 題目三：發送 BaseGame 滾停後的贏分事件
        this.triggerBaseGameWinDisplay();
        
        // 其他現有邏輯...
    }

    private triggerBaseGameWinDisplay(): void {
        const spinResult = this.gameDataProxy.spinEventData;
        const baseGameWin = spinResult.baseGameResult.baseGameTotalWin;
        
        // 只有在有贏分時才發送事件
        if (baseGameWin > 0) {
            // 發送龍珠顯示贏分事件，帶上贏分參數
            this.sendNotification(DragonUpEvent.ON_BASEGAME_WIN_DISPLAY, {
                winAmount: baseGameWin,
                formattedWin: this._gameDataProxy.convertCredit2Cash(baseGameWin)
            });
        }
    }
}
```

**關鍵實作點**：
- 在 `execute()` 方法中適當位置調用觸發函數
- 檢查 `baseGameWin > 0` 確保只有真正有贏分才顯示
- 同時提供原始數值和格式化字串，增加使用彈性
- 使用 `convertCredit2Cash()` 確保顯示格式一致

#### 步驟3：實作事件接收和處理

**在 `BallHitViewMediator.ts` 中修改**：

```typescript
public listNotificationInterests(): Array<any> {
    return [
        // 現有事件列表...
        DragonUpEvent.ON_BASEGAME_WIN_DISPLAY,
    ];
}

public handleNotification(notification: puremvc.INotification): void {
    let name = notification.getName();
    switch (name) {
        // 現有case處理...
        
        case DragonUpEvent.ON_BASEGAME_WIN_DISPLAY:
            this.displayBaseGameWinOnBall(notification.getBody());
            break;
    }
}

private displayBaseGameWinOnBall(data: { winAmount: number; formattedWin: string }): void {
    // 檢查目前場景是否為 Game_1 (BaseGame)
    if (this.gameDataProxy.curScene !== GameScene.Game_1) {
        return;
    }

    // 在上方大龍珠顯示當局 BaseGame 贏分
    // playType 0 表示 BaseGame 的顯示模式
    this.view.setBallCredit(data.formattedWin, 0);
}
```

**設計考量**：
- 場景檢查確保只在 BaseGame 中觸發
- `playType 0` 對應 BaseGame 的顯示模式
- 使用現有的 `setBallCredit()` 方法，確保顯示一致性

#### 步驟4：實作自動清除邏輯

**在 `BallHitViewMediator.ts` 中修改 spin 處理**：

```typescript
private onSpinDown() {
    // 在 BaseGame 中，spin 開始時清除龍珠上的贏分顯示
    if (this.gameDataProxy.curScene === GameScene.Game_1) {
        this.hideBallCredit();
    }
    
    // 現有的其他處理邏輯...
    if (this.gameDataProxy.gameState == StateMachineProxy.GAME4_END) {
        if (this.bCanUseSkip == false) return;
        this.bCanUseSkip = false;
        this.tempFunc();
    }
}
```

**自動清除機制**：
- 利用現有的 `ScreenEvent.ON_SPIN_DOWN` 事件
- 在玩家點擊 spin 按鈕時立即清除顯示
- 使用現有的 `hideBallCredit()` 方法確保清除徹底

### 核心技術細節

#### 1. 龍珠顯示機制

**現有系統架構**：
```typescript
BallHitView.setBallCredit(score, playType) 
    ↓
JackPotPerformControl.OnScoreCollect(score, playType)
    ↓
實際的龍珠UI更新
```

**playType 參數說明**：
- `0`：BaseGame 模式（我們使用的）
- `1`：Free Game 模式
- `2`：Dragon Up 模式
- `3`：隱藏模式

#### 2. 事件時序控制

**執行順序**：
```
1. 玩家點擊 spin
2. 伺服器回傳結果
3. 滾軸停止 → GAME_Game1RollCompleteCommand.execute()
4. 計算並顯示各種結果（連線、特殊獎等）
5. 觸發龍珠贏分顯示 ← 我們的實作點
6. 玩家看到完整結果
```

#### 3. 場景生命週期管理

**場景檢查的重要性**：
- 確保只在 BaseGame 場景觸發
- 避免在 Free Game 或其他特殊場景中誤觸發
- 保持各場景功能的獨立性

### 測試與驗證

#### 自動測試流程
1. 啟動遊戲進入 BaseGame
2. 進行 spin 操作
3. 觀察中獎局：
   - 滾停後上方大龍珠是否顯示贏分
   - 顯示的金額是否正確
   - 格式是否與遊戲一致
4. 下一次 spin：
   - 點擊 spin 按鈕時龍珠顯示是否立即清除
   - 新局結果是否正確更新

#### 邊界情況測試
1. **無贏分局**：確認不會顯示任何內容
2. **場景切換**：確認在其他場景不會觸發
3. **連續中獎**：確認每局都正確更新顯示
4. **大額贏分**：確認格式化顯示正確

### 技術亮點

#### 1. 無侵入性設計
- 完全利用現有的系統組件
- 不需要修改 UI Prefab 或創建新組件
- 與現有 Free Game 龍珠功能完美共存

#### 2. 事件驅動架構
- 遵循 PureMVC 設計模式
- 低耦合，易於維護和擴展
- 符合現有代碼風格和架構

#### 3. 用戶體驗考量
- 即時反饋：滾停後立即顯示
- 自動清理：下次 spin 自動清除，避免視覺混亂
- 一致性：使用與 Free Game 相同的顯示邏輯

---

## 總結

### 技術成果

#### 題目一成果
- ✅ **Console輸出**：格式化顯示中獎信息
- ✅ **畫面顯示**：HTML覆蓋層在螢幕中央顯示
- ✅ **自動觸發**：真實遊戲中獎時自動顯示
- ✅ **PureMVC整合**：完美融入現有架構

#### 題目二成果
- ✅ **持續動畫**：整個顯示期間都有動態效果
- ✅ **視覺增強**：搖擺、發光、縮放多重效果
- ✅ **性能優化**：輕量級CSS動畫，不影響遊戲性能
- ✅ **完美整合**：與題目一無縫配合

#### 題目三成果
- ✅ **事件驅動**：完美整合PureMVC事件系統
- ✅ **即時顯示**：BaseGame滾停後立即顯示贏分
- ✅ **自動清除**：下次spin自動清除，用戶體驗佳
- ✅ **無侵入性**：利用現有組件，不破壞原架構

### 開發思路總結

這個實作展示了幾個重要的開發思路：

1. **由簡到繁**：先實現Console輸出，再處理UI顯示，最後添加動畫和龍珠顯示
2. **架構理解**：深入理解現有系統的設計模式（PureMVC、事件系統）
3. **創新解決**：當傳統方法遇到困難時，採用HTML覆蓋層創新方案
4. **代碼品質**：最終清理冗餘，保持結構清潔
5. **用戶體驗**：重視視覺效果和交互反饋
6. **系統整合**：充分利用現有組件，減少重複開發

### 學習價值

通過這個專案，我們學習了：

- **PureMVC架構模式**：Command-Mediator-Proxy的分工協作
- **Cocos Creator與Web技術整合**：HTML覆蓋層技術的應用
- **CSS動畫技術**：keyframes、transform、animation的使用
- **TypeScript在遊戲開發中的應用**
- **事件驅動設計**：解耦合的系統通訊機制
- **現有系統整合**：如何在不破壞原架構下新增功能
- **問題分析與創新解決能力**

---

## 題目四：倒數五秒狀態

### 實作概念

在game1的spin和rollComplete之間插入一個新的狀態，顯示5秒倒數，使用HTML覆蓋層全程式實作。

### 核心設計思路

#### 1. 狀態機修改
```
原流程：GAME1_SPIN → GAME1_ROLLCOMPLETE
新流程：GAME1_SPIN → GAME1_COUNTDOWN → GAME1_ROLLCOMPLETE
```

#### 2. 組件分工
- **StateMachineProxy**：新增倒數狀態定義和轉換邏輯
- **Command**：`Game1CountdownCommand` - 負責倒數邏輯控制
- **Mediator**：`CountdownDisplayMediator` - 負責HTML覆蓋層顯示
- **BaseReelViewMediator**：修改觸發點從ROLLCOMPLETE改為COUNTDOWN

### 詳細實作步驟

#### 步驟1：創建基礎倒數Command

**`assets/src/sgv3/command/state/Game1CountdownCommand.ts`**
```typescript
export class Game1CountdownCommand extends StateCommand {
    public static readonly NAME = StateMachineProxy.GAME1_EV_COUNTDOWN;

    public execute(notification: puremvc.INotification): void {
        this.notifyWebControl();
        // 基礎5秒倒數邏輯
        GlobalTimer.getInstance().registerTimer('game1Countdown', 5, () => {
            this.changeState(StateMachineProxy.GAME1_ROLLCOMPLETE);
        }, this).start();
    }
}
```

#### 步驟2：創建遊戲專案倒數Command

**`assets/src/game/command/state/GAME_Game1CountdownCommand.ts`**
```typescript
export class GAME_Game1CountdownCommand extends Game1CountdownCommand {
    public execute(notification: puremvc.INotification): void {
        this.notifyWebControl();
        
        // 觸發HTML覆蓋層顯示
        this.sendNotification('SHOW_COUNTDOWN_DISPLAY');
        
        // 開始倒數邏輯：每秒更新顯示，5秒後完成
        this.startCountdownProcess();
    }
    
    private startCountdownProcess(): void {
        // 實現每秒更新的倒數邏輯
        // 5→4→3→2→1→完成進入ROLLCOMPLETE
    }
}
```

#### 步驟3：創建HTML覆蓋層控制器

**`assets/src/game/mediator/CountdownDisplayMediator.ts`**
```typescript
export class CountdownDisplayMediator extends BaseMediator<any> {
    public listNotificationInterests(): Array<any> {
        return [
            'SHOW_COUNTDOWN_DISPLAY',
            'UPDATE_COUNTDOWN_DISPLAY', 
            'HIDE_COUNTDOWN_DISPLAY'
        ];
    }

    private showCountdownDisplay(): void {
        // 創建HTML覆蓋層，樣式類似題目一
        this.htmlOverlay = document.createElement('div');
        this.htmlOverlay.style.cssText = `
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700; font-size: 120px;
            // 加入脈衝動畫效果
        `;
    }
}
```

#### 步驟4：修改狀態機

**`assets/src/sgv3/proxy/StateMachineProxy.ts`**
```typescript
// 新增狀態常數
public static readonly GAME1_COUNTDOWN: string = 'game1Countdown';
public static readonly GAME1_EV_COUNTDOWN: string = 'game1EvCountdown';

// 修改狀態轉換映射
this.stateMachineMap[StateMachineProxy.GAME1_SPIN] = [StateMachineProxy.GAME1_COUNTDOWN];
this.stateMachineMap[StateMachineProxy.GAME1_COUNTDOWN] = [StateMachineProxy.GAME1_ROLLCOMPLETE];

// 新增事件映射
this.stateEventMap[StateMachineProxy.GAME1_COUNTDOWN] = StateMachineProxy.GAME1_EV_COUNTDOWN;
```

#### 步驟5：修改滾軸觸發點

**`assets/src/sgv3/mediator/base/BaseReelViewMediator.ts`**
```typescript
protected onReelsRollComplete(): void {
    switch (this.gameDataProxy.curScene) {
        case GameScene.Game_1:
            // 改為觸發倒數狀態而不是直接進入ROLLCOMPLETE
            this.sendNotification(
                StateMachineCommand.NAME,
                new StateMachineObject(StateMachineProxy.GAME1_COUNTDOWN)
            );
            break;
    }
}
```

#### 步驟6：註冊新組件

**`assets/src/game/command/GAME_RegisterPuremvcCommand.ts`**
```typescript
protected registerMediator(notification: puremvc.INotification): void {
    super.registerMediator(notification);
    
    // 註冊倒數顯示 Mediator
    this.facade.registerMediator(new CountdownDisplayMediator());
}
```

### 視覺效果設計

#### 倒數顯示特效
- **居中顯示**：螢幕正中央的大型倒數數字
- **視覺增強**：金色文字、發光脈衝、時鐘圖示⏰
- **動態更新**：每秒更新數字，搭配彈跳動畫
- **顏色變化**：最後1-2秒數字變紅色增加緊迫感
- **自動清除**：倒數完成後平滑淡出

#### CSS動畫效果
```css
@keyframes countdownPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
}

@keyframes numberBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}
```

### 實作關鍵要點

#### 1. 狀態機安全修改
- **漸進式修改**：先創建文件再修改狀態機
- **完整註冊**：確保所有Command都正確註冊
- **狀態流程**：保持原有遊戲邏輯完整性

#### 2. 計時器管理
```typescript
// 避免GlobalTimer ID衝突
private scheduleCountdownTimer(): void {
    GlobalTimer.getInstance().removeTimer(this.TIMER_KEY); // 先清除
    GlobalTimer.getInstance().registerTimer(this.TIMER_KEY, 1, () => {
        this.onCountdownTick();
    }, this).start();
}
```

#### 3. HTML覆蓋層技術
- 使用與題目一相同的技術方案
- `position: fixed` + `z-index: 10000` 確保最頂層顯示
- 完全繞過Cocos Creator渲染系統

### 技術挑戰與解決方案

#### 挑戰1：狀態機修改風險
**解決方案**：採用漸進式實作順序，避免中間狀態的編譯錯誤

#### 挑戰2：計時器ID衝突
**解決方案**：每次註冊前先清除舊計時器，確保ID唯一性

#### 挑戰3：與現有流程整合
**解決方案**：修改BaseReelViewMediator觸發點，保持其他邏輯不變

### 測試驗證

#### 自動測試流程
1. 啟動遊戲進入Game1場景
2. 點擊SPIN按鈕
3. 觀察：滾軸停止後是否出現倒數5秒畫面
4. 確認：倒數完成後是否正常進入ROLLCOMPLETE流程

#### 手動測試
```javascript
// 瀏覽器Console測試
testCountdownDisplay()  // 測試倒數顯示
hideCountdownDisplay()  // 手動隱藏
```

---

## 總結

### 四題整體技術成果

這四個練習題展示了完整的遊戲開發技術棧：

#### 題目一：數據處理與UI顯示
- ✅ 學習遊戲數據解析和處理
- ✅ 掌握HTML覆蓋層技術
- ✅ 理解PureMVC事件通訊機制

#### 題目二：動畫與視覺效果  
- ✅ CSS動畫技術應用
- ✅ 視覺效果設計思維
- ✅ 性能優化考量

#### 題目三：系統整合與事件驅動
- ✅ 事件驅動架構設計
- ✅ 現有組件的深度利用
- ✅ 用戶體驗設計

#### 題目四：狀態機與架構修改
- ✅ 核心系統狀態機理解和修改
- ✅ 複雜系統的安全改動策略
- ✅ 計時器和生命週期管理

### 學習價值總結

通過這個專案，我們學習了：

- **PureMVC架構模式**：Command-Mediator-Proxy的分工協作
- **Cocos Creator與Web技術整合**：HTML覆蓋層技術的應用
- **CSS動畫技術**：keyframes、transform、animation的使用
- **TypeScript在遊戲開發中的應用**
- **事件驅動設計**：解耦合的系統通訊機制
- **現有系統整合**：如何在不破壞原架構下新增功能
- **狀態機設計與修改**：遊戲核心邏輯的理解和安全修改
- **問題分析與創新解決能力**

這不僅完成了功能需求，更重要的是掌握了遊戲開發中的架構設計和問題解決思維，學會了如何在複雜系統中找到最佳的整合點。