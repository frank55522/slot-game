# 練習題技術實作指南：老虎機遊戲增強功能

## 實作目標

### 題目一：中獎連線顯示功能
在老虎機遊戲中實現中獎連線顯示功能，當玩家中獎時自動顯示連線結果（如「M1 × 5」）。

### 題目二：Show Win 動畫效果
在 show win 時透過 TimelineTool 播放動畫，為中獎連線顯示增加視覺效果。

---

## 整體架構思路

### 1. 核心流程設計
```
遊戲轉動 → 伺服器回傳結果 → 解析中獎數據 → 顯示中獎信息 + 播放動畫
     ↓              ↓              ↓              ↓
   玩家操作    GAME_ParseState    PureMVC通知    HTML覆蓋層
              WinResultCommand    機制          + CSS動畫
```

### 2. MVC架構應用
- **Model**：中獎數據 (WAY_WinInfo)
- **View**：HTML覆蓋層顯示 + 動畫效果
- **Controller**：WinLineDisplayMediator

---

## 題目一：中獎連線顯示功能

### 詳細實作步驟

#### 步驟1：找到數據處理入口點

**目標**：找到遊戲處理中獎結果的地方

**方法**：
1. 搜尋專案中與「Win」、「Result」相關的文件
2. 找到 `GAME_ParseStateWinResultCommand.ts`
3. 這個文件負責解析伺服器回傳的遊戲結果

**關鍵代碼位置**：
```typescript
// GAME_ParseStateWinResultCommand.ts 第52-53行
this.triggerWinLineDisplay(); // 我們要修改的地方
```

#### 步驟2：理解數據結構

**中獎數據格式 (WAY_WinInfo)**：
```typescript
{
    symbolId: number,     // 符號ID (0=WILD, 2=M1, 6=Q, 7=K等)
    hitCount: number,     // 連線數量
    symbolWin: number,    // 中獎金額
    hitOdds: number,      // 賠率
    hitNumber: number     // 連線編號
}
```

**實際數據範例**：
```typescript
[
    { symbolId: 3, hitCount: 4, symbolWin: 3.00 },  // M2 × 4 = 3.00
    { symbolId: 6, hitCount: 3, symbolWin: 1.50 }   // Q × 3 = 1.50
]
```

#### 步驟3：實現數據攔截和Console輸出

**在 `GAME_ParseStateWinResultCommand.ts` 中修改**：

```typescript
private triggerWinLineDisplay() {
    if (this.gameDataProxy.stateWinData.wayInfos.length > 0) {
        // 過濾有效中獎 (symbolWin > 0)
        const validWinInfos = this.gameDataProxy.stateWinData.wayInfos
            .filter(info => info.symbolWin > 0);
        
        if (validWinInfos.length > 0) {
            // === Console輸出實現 ===
            console.log('=== 本局中獎連線結果 ===');
            validWinInfos.forEach((winInfo) => {
                const symbolName = this.getSymbolNameById(winInfo.symbolId);
                console.log(`${symbolName} × ${winInfo.hitCount} = ${winInfo.symbolWin.toFixed(2)}`);
            });
            console.log(`總共 ${validWinInfos.length} 條中獎連線`);
            
            // 發送PureMVC通知觸發UI顯示
            this.sendNotification('SHOW_WIN_LINES', validWinInfos);
        }
    }
}

// 符號ID轉換函數
private getSymbolNameById(symbolId: number): string {
    const symbolMap = {
        0: 'WILD', 1: 'C1', 2: 'M1', 3: 'M2', 4: 'M3',
        5: 'J', 6: 'Q', 7: 'K', 8: 'A', 9: '10', 10: '9'
    };
    return symbolMap[symbolId] || `Symbol_${symbolId}`;
}
```

**關鍵點解析**：
- `filter(info => info.symbolWin > 0)`：只顯示真正中獎的連線
- `getSymbolNameById()`：將數字ID轉為可讀的符號名稱
- `sendNotification()`：發送PureMVC事件觸發UI顯示

#### 步驟4：實現UI顯示邏輯

**創建 `WinLineDisplayMediator.ts`**：

```typescript
import { _decorator } from 'cc';
import BaseMediator from '../../base/BaseMediator';

@ccclass('WinLineDisplayMediator')
export class WinLineDisplayMediator extends BaseMediator<any> {
    public static NAME: string = 'WinLineDisplayMediator';
    private htmlOverlay: HTMLElement | null = null;

    // 監聽的PureMVC事件
    public listNotificationInterests(): Array<any> {
        return ['SHOW_WIN_LINES', 'HIDE_WIN_LINES'];
    }

    // 處理事件通知
    public handleNotification(notification: puremvc.INotification): void {
        switch (notification.getName()) {
            case 'SHOW_WIN_LINES':
                this.showHTMLWinText(notification.getBody());
                break;
            case 'HIDE_WIN_LINES':
                this.hideHTMLWinText();
                break;
        }
    }

    // HTML覆蓋層實現
    private showHTMLWinText(winData: any[]) {
        // 組合顯示文字
        const winTexts = winData.map((win) => {
            const symbolName = this.getSymbolNameById(win.symbolId);
            return `${symbolName} × ${win.hitCount} = ${win.symbolWin.toFixed(2)}`;
        });
        
        // 創建HTML元素
        this.htmlOverlay = document.createElement('div');
        this.htmlOverlay.style.cssText = `
            position: fixed;           /* 固定位置，不受頁面滾動影響 */
            top: 50%; left: 50%;      /* 螢幕中央 */
            transform: translate(-50%, -50%);  /* 精確置中 */
            background: rgba(0, 0, 0, 0.8);   /* 半透明黑底 */
            color: #FFD700;           /* 金色文字 */
            font-size: 32px;          /* 大字體 */
            font-weight: bold;        /* 粗體 */
            text-align: center;       /* 文字置中 */
            padding: 30px;            /* 內邊距 */
            border-radius: 15px;      /* 圓角 */
            border: 3px solid #FFD700; /* 金色邊框 */
            z-index: 10000;           /* 最高層級，確保顯示在最上方 */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);  /* 文字陰影 */
            box-shadow: 0 0 20px rgba(255,215,0,0.6);  /* 發光效果 */
        `;
        
        // 設置顯示內容
        this.htmlOverlay.innerHTML = `🎉 中獎連線 🎉<br>${winTexts.join('<br>')}`;
        
        // 添加到頁面
        document.body.appendChild(this.htmlOverlay);
        
        // 3秒後自動隱藏
        setTimeout(() => this.hideHTMLWinText(), 3000);
    }
}
```

#### 步驟5：系統整合

**創建 `WinLineTestTrigger.ts`**：

```typescript
@ccclass('WinLineTestTrigger')
export class WinLineTestTrigger extends Component {
    onLoad() {
        // 延遲2秒等待遊戲系統初始化
        setTimeout(() => this.initialize(), 2000);
    }

    private initialize() {
        // 註冊Mediator到PureMVC系統
        this.registerWinLineMediator();
        
        // 提供測試函數
        this.exposeTestFunctions();
    }

    private registerWinLineMediator() {
        const facade = puremvc.Facade.getInstance();
        const mediator = new WinLineDisplayMediator();
        facade.registerMediator(mediator);
    }
}
```

---

## 題目二：Show Win 動畫效果

### 實作概念

基於題目一的 HTML 覆蓋層，透過 CSS 動畫實現視覺效果，讓中獎顯示更加顯眼和吸引人。

### 動畫設計思路

#### 1. 持續動畫系統
- **搖擺彈跳**：模擬慶祝的興奮感
- **光暈脈衝**：營造發光效果
- **整個顯示期間持續播放**：確保視覺吸引力

#### 2. 動畫時間軸
```
出現(0.01s) → 持續動畫(3s) → 消失動畫(0.5s)
     ↓            ↓              ↓
   立即顯示   搖擺+發光       縮小淡出
```

### 實作步驟

#### 步驟1：CSS 動畫定義

**在 `WinLineDisplayMediator.ts` 中新增動畫樣式**：

```typescript
// 先添加CSS動畫定義到頁面
if (!document.getElementById('win-bounce-animation')) {
    const style = document.createElement('style');
    style.id = 'win-bounce-animation';
    style.textContent = `
        @keyframes winShake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            10% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            20% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            30% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            40% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            50% { transform: translate(-50%, -50%) rotate(0deg) scale(1.15); }
            60% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            70% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
            80% { transform: translate(-50%, -50%) rotate(1deg) scale(1.1); }
            90% { transform: translate(-50%, -50%) rotate(-1deg) scale(1.05); }
        }
        @keyframes winGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255,215,0,0.6); }
            50% { box-shadow: 0 0 40px rgba(255,215,0,1), 0 0 60px rgba(255,215,0,0.8); }
        }
    `;
    document.head.appendChild(style);
}
```

#### 步驟2：動畫觸發邏輯

**修改顯示函數應用動畫**：

```typescript
// 立即顯示並開始持續動畫
setTimeout(() => {
    if (this.htmlOverlay) {
        // 先顯示元素
        this.htmlOverlay.style.opacity = '1';
        this.htmlOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // 開始持續的組合動畫
        this.htmlOverlay.style.animation = `
            winShake 0.8s ease-in-out infinite,
            winGlow 1.5s ease-in-out infinite
        `;
    }
}, 10);
```

#### 步驟3：視覺效果增強

**增強顯示效果**：

```typescript
this.htmlOverlay.style.cssText = `
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: rgba(0, 0, 0, 0.9);        /* 更深的背景 */
    color: #FFD700;
    font-family: Arial, sans-serif;
    font-size: 36px;                       /* 更大的字體 */
    font-weight: bold;
    text-align: center;
    padding: 40px;                         /* 更大的內邊距 */
    border-radius: 20px;                   /* 更大的圓角 */
    border: 4px solid #FFD700;             /* 更粗的邊框 */
    z-index: 10000;
    text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 10px rgba(255,215,0,0.8); /* 雙重陰影 */
    box-shadow: 0 0 20px rgba(255,215,0,0.6);
    white-space: pre-line;
    max-width: 700px;
    word-wrap: break-word;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
`;
```

#### 步驟4：消失動畫處理

**優雅的退場效果**：

```typescript
private hideHTMLWinTextWithAnimation() {
    if (this.htmlOverlay && this.htmlOverlay.parentNode) {
        console.log('[WinLineDisplayMediator] 隱藏HTML覆蓋層（帶動畫）');
        
        // 停止持續動畫，開始淡出
        this.htmlOverlay.style.animation = 'none';
        this.htmlOverlay.style.transition = 'all 0.5s ease-out';
        this.htmlOverlay.style.transform = 'translate(-50%, -50%) scale(0.5)';
        this.htmlOverlay.style.opacity = '0';
        
        // 動畫完成後移除元素
        setTimeout(() => {
            if (this.htmlOverlay && this.htmlOverlay.parentNode) {
                this.htmlOverlay.parentNode.removeChild(this.htmlOverlay);
                this.htmlOverlay = null;
            }
        }, 500);
    }
}
```

### 動畫效果說明

#### 1. **winShake 動畫**
- **效果**：輕微的旋轉搖擺 + 縮放變化
- **週期**：0.8秒一個循環
- **變化範圍**：旋轉 ±1度，縮放 1.0-1.15倍
- **目的**：模擬興奮慶祝的感覺

#### 2. **winGlow 動畫**
- **效果**：光暈強弱變化
- **週期**：1.5秒一個循環
- **變化範圍**：陰影從 20px 到 60px
- **目的**：營造發光脈衝效果

#### 3. **組合效果**
- **同時播放**：兩個動畫疊加運行
- **持續時間**：整個3秒顯示期間
- **視覺體驗**：持續的動態效果，極難忽視

---

## 技術難點與解決方案

### 難點1：Cocos Creator UI渲染問題

**問題**：純程式碼創建的UI組件無法顯示

**原因分析**：
- Cocos Creator通常使用Prefab管理UI
- 渲染層級複雜，程式碼創建的組件可能被遮蓋
- Canvas設置和相機層級影響顯示

**解決方案**：HTML覆蓋層
```typescript
// 關鍵CSS屬性
position: fixed;     // 脫離文檔流，固定位置
z-index: 10000;     // 最高層級
transform: translate(-50%, -50%);  // 精確置中
```

### 難點2：PureMVC架構整合

**理解要點**：
- **Command**：處理業務邏輯 (ParseStateWinResultCommand)
- **Mediator**：管理UI顯示 (WinLineDisplayMediator)  
- **Notification**：組件間通訊機制

**通訊流程**：
```
Command.sendNotification() → Facade → Mediator.handleNotification()
```

### 難點3：動畫性能優化

**挑戰**：CSS動畫可能影響遊戲性能

**解決策略**：
- **有限時間**：動畫只播放3秒
- **硬件加速**：使用transform屬性觸發GPU加速
- **動畫清理**：及時停止和移除動畫元素
- **輕量級動畫**：避免過於複雜的動畫效果

### 難點4：數據格式轉換

**挑戰**：將遊戲內部的數字ID轉為玩家可讀的符號

**實現**：映射表 + 函數封裝
```typescript
const symbolMap = {
    0: 'WILD', 2: 'M1', 6: 'Q', 7: 'K'
    // ...更多映射
};
```

---

## 測試與驗證

### 自動測試（推薦）
1. 啟動遊戲
2. 進行轉動操作
3. 中獎時觀察：
   - Console輸出是否正確
   - 畫面顯示是否出現
   - 動畫效果是否播放
   - 3秒後是否自動消失

### 手動測試
```javascript
// 瀏覽器Console執行
testWinLineDisplay()  // 模擬中獎顯示
hideWinLineDisplay()  // 手動隱藏測試
```

---

## 擴展思路

### 可能的改進方向

#### 功能增強
1. **多種動畫模式**：根據中獎金額使用不同動畫
2. **音效整合**：中獎時播放對應音效
3. **多語言支持**：根據遊戲語言顯示不同文字
4. **自定義樣式**：允許玩家自定義顯示樣式

#### 技術優化
1. **配置文件**：將符號映射表移到配置文件
2. **事件解耦**：使用更細粒度的事件系統
3. **錯誤處理**：添加容錯機制
4. **動畫庫**：建立可重用的動畫組件庫

### 架構優化

#### 1. 組件化設計
```typescript
// 動畫控制器
class WinAnimationController {
    static playBounceAnimation(element: HTMLElement): void
    static playGlowAnimation(element: HTMLElement): void
    static stopAllAnimations(element: HTMLElement): void
}
```

#### 2. 配置驅動
```typescript
// 動畫配置
interface AnimationConfig {
    duration: number;
    easing: string;
    effects: AnimationEffect[];
}
```

---

## 總結

### 技術成果

#### 題目一成果
- ✅ **Console輸出**：格式化顯示中獎信息
- ✅ **畫面顯示**：HTML覆蓋層在螢幕中央顯示
- ✅ **自動觸發**：真實遊戲中獎時自動顯示
- ✅ **PureMVC整合**：完美融入現有架構

#### 題目二成果
- ✅ **持續動畫**：整個顯示期間都有動態效果
- ✅ **視覺增強**：搖擺、發光、縮放多重效果
- ✅ **性能優化**：輕量級CSS動畫，不影響遊戲性能
- ✅ **完美整合**：與題目一無縫配合

### 開發思路總結

這個實作展示了幾個重要的開發思路：

1. **由簡到繁**：先實現Console輸出，再處理UI顯示，最後添加動畫
2. **架構理解**：深入理解現有系統的設計模式
3. **創新解決**：當傳統方法遇到困難時，採用HTML覆蓋層創新方案
4. **代碼品質**：最終清理冗餘，保持結構清潔
5. **用戶體驗**：重視視覺效果和交互反饋

### 學習價值

通過這個專案，我們學習了：

- **PureMVC架構模式**：Command-Mediator-Proxy的分工協作
- **Cocos Creator與Web技術整合**：HTML覆蓋層技術的應用
- **CSS動畫技術**：keyframes、transform、animation的使用
- **TypeScript在遊戲開發中的應用**
- **問題分析與創新解決能力**

這不僅完成了功能需求，更重要的是掌握了遊戲開發中的架構設計和問題解決思維。