# 練習2 第一題實作指南

## 題目描述
調整feature game結算流程：當free games或dragon bonus games結束時，如果總贏分低於Big Win門檻，則跳過結算面板直接返回BaseGame。

## 1. 實作前的思路構築

### 1.1 問題分析
- **核心需求**：條件性跳過結算面板顯示
- **觸發條件**：總贏分 < Big Win門檻
- **影響範圍**：Free Game結算、Dragon Bonus結算
- **預期行為**：低於門檻時直接回到BaseGame，達到門檻時正常顯示結算面板

### 1.2 技術思考點
1. 需要找到Big Win門檻的定義位置
2. 需要找到結算面板顯示的控制邏輯
3. 需要了解PureMVC的Command模式
4. 需要理解遊戲狀態流轉機制

## 2. 專案架構理解

### 2.1 需要了解的專案核心部分

#### PureMVC架構模式
- **Command**：處理業務邏輯的指令
- **Proxy**：數據管理代理
- **Mediator**：視圖中介者
- 遊戲主要使用Command來控制遊戲流程

#### 關鍵目錄結構
```
assets/src/
├── sgv3/                    # 框架核心
│   ├── command/            # 通用指令
│   ├── proxy/              # 數據代理
│   └── vo/                 # 值對象
├── game/                   # 遊戲特定實作
│   ├── command/            # 遊戲指令
│   └── proxy/              # 遊戲代理
```

### 2.2 Big Win門檻定義位置
**檔案位置**：`assets/src/sgv3/command/byGame/MultipleCalculateCommand.ts`

```typescript
// 一般渠道的門檻定義
const winTypeRangesNormal = [
    { min: 15, max: 35, type: WinType.bigWin, duration: BaseScoringDuration.Scoring_Win01 },
    { min: 35, max: 100, type: WinType.megaWin, duration: BaseScoringDuration.Scoring_Win02 },
    { min: 100, max: Number.MAX_VALUE, type: WinType.epicWin, duration: BaseScoringDuration.Scoring_Win03 }
];

// 全渠道的門檻定義（較高）
const winTypeRangesOmni = [
    { min: 17, max: 35, type: WinType.bigWin, duration: BaseScoringDuration.Scoring_Win01 },
    // ...
];
```

**重點**：專案主要使用一般渠道的15倍作為Big Win門檻

## 3. 實作方法

### 3.1 定位結算控制指令

#### Free Game結算指令
**檔案位置**：`assets/src/game/command/state/GAME_Game2EndCommand.ts`
**核心方法**：`showCreditBoard()` - 控制結算面板顯示

#### Dragon Bonus結算指令
**檔案位置**：`assets/src/game/command/dragon-up/GAME_4_CreditCollectResultCommand.ts`
**核心方法**：`showCreditBoard()` - 控制結算面板顯示

### 3.2 實作跳過邏輯

在兩個結算指令中都添加相同的判斷邏輯：

```typescript
protected showCreditBoard() {
    // ... 原有邏輯 ...
    
    let totalWin: number = this.gameDataProxy.convertCredit2Cash(
        this.gameDataProxy.spinEventData.playerTotalWin  // 或對應的贏分來源
    );

    // 檢查是否達到Big Win標準，未達到則跳過結算面板
    if (!this.isBigWinOrAbove(totalWin)) {
        // 贏分小於Big Win，直接跳過結算面板回到BaseGame
        this.delayCloseBoard();
        return;
    }

    // 達到Big Win以上，正常顯示結算面板
    this.sendNotification(StateWinEvent.SHOW_LAST_CREDIT_BOARD, totalWin);
    // ... 後續邏輯 ...
}

/**
 * 判定贏分是否達到Big Win標準
 * @param totalWin 總贏分金額
 * @returns true: 達到Big Win以上, false: 未達到Big Win
 */
private isBigWinOrAbove(totalWin: number): boolean {
    const curTotalBet = this.gameDataProxy.curTotalBet;
    const winMultiple = MathUtil.div(totalWin, curTotalBet);
    
    // Big Win門檻：使用臨時設定或預設15倍
    const bigWinThreshold = this.gameDataProxy.tempBigWinThreshold;
    
    return winMultiple >= bigWinThreshold;
}
```

### 3.3 添加測試功能

#### 數據層添加測試屬性
**檔案位置**：`assets/src/sgv3/vo/config/GameData.ts`
```typescript
/** 臨時Big Win門檻測試 */
public tempBigWinThreshold: number = 15;
```

#### 代理層添加存取方法
**檔案位置**：`assets/src/sgv3/proxy/GameDataProxy.ts`
```typescript
/** 臨時Big Win門檻測試 */
public get tempBigWinThreshold(): number {
    return this._gameData.tempBigWinThreshold;
}
public set tempBigWinThreshold(_val: number) {
    this._gameData.tempBigWinThreshold = _val;
}
```

#### Web橋接層添加Console指令
**檔案位置**：`assets/src/sgv3/proxy/WebBridgeProxy.ts`

在 `initAPI()` 方法中註冊指令：
```typescript
// Console指令
window['setBigWinThreshold'] = (_threshold: number) => this.setBigWinThreshold(_threshold);
```

實作指令方法：
```typescript
/**
 * 設定Big Win門檻測試
 * 使用方式：setBigWinThreshold(20) - 設定為20倍
 */
public setBigWinThreshold(threshold: number): void {
    if (threshold && threshold > 0) {
        this.gameDataProxy.tempBigWinThreshold = threshold;
        console.log(`🎯 Big Win門檻已設定為 ${threshold}x`);
        console.log('💡 提示：此設定會在下次feature game結算時生效');
    } else {
        console.log('❌ 請輸入大於0的數值');
    }
}
```

## 4. 關鍵技術點說明

### 4.1 PureMVC Command模式
- Command負責處理具體的業務邏輯
- 透過 `sendNotification()` 發送事件通知
- 透過 `facade.retrieveProxy()` 獲取數據代理

### 4.2 數學計算
使用 `MathUtil.div()` 進行浮點數除法，避免JavaScript浮點數精度問題

### 4.3 狀態流轉
- `delayCloseBoard()` 方法負責清理並轉換到下一個遊戲狀態
- 使用 `GlobalTimer` 進行時間控制

### 4.4 通知機制
- `StateWinEvent.SHOW_LAST_CREDIT_BOARD` 用於顯示結算面板
- `WinEvent.FORCE_WIN_DISPOSE` 用於強制清理贏分顯示
- `CheckGameFlowCommand.NAME` 用於檢查遊戲流程

## 5. 測試驗證

### 5.1 測試方法
1. 開啟遊戲後在Console執行：`setBigWinThreshold(20)`
2. 觸發Free Game或Dragon Bonus
3. 觀察結算時的行為

### 5.2 預期結果
- 當實際倍數(15.4x) < 設定門檻(20x)時：跳過結算面板
- 當實際倍數 >= 設定門檻時：正常顯示結算面板
- Big Win動畫不受影響（由其他邏輯控制）

## 6. 學習重點總結

### 6.1 專案架構理解
- 掌握PureMVC的MVC三層架構
- 理解Command-Proxy-Mediator的職責分工
- 了解遊戲狀態機的運作方式

### 6.2 程式設計模式
- 策略模式：條件性執行不同邏輯
- 代理模式：透過Proxy管理數據訪問
- 觀察者模式：透過通知機制解耦組件

### 6.3 遊戲開發實務
- 了解遊戲結算流程的設計
- 學習如何添加測試功能而不影響正式邏輯
- 掌握Console指令的實作方式

### 6.4 TypeScript開發技巧
- 介面設計與實作
- 類型安全的數據訪問
- 模組化程式組織

## 7. 可能的延伸思考

1. **效能考量**：是否需要快取門檻值避免重複計算？
2. **擴展性**：如何支援不同遊戲模式的不同門檻？
3. **測試完整性**：如何編寫自動化測試驗證此功能？
4. **用戶體驗**：跳過結算面板是否需要其他視覺回饋？

這些思考點可以幫助更深入理解遊戲系統設計的複雜性和考量因素。

---

# 練習2 第二題實作指南

## 題目描述
在BaseGame滾停後若有觸發特色遊戲（盤面上有6顆或以上的分數球），則在收集球分之前卡住流程，讓盤面上的分數球做任意表演（簡單的縮放動畫或播放任意粒子特效都可以），表演完後再繼續後續收集球分的流程，並請說明卡住流程及分數球表演的作法。

## 1. 實作前的思路構築

### 1.1 問題拆解
- **核心需求**：在收集球分前插入表演動畫
- **觸發條件**：BaseGame滾停 + ballCount >= 6
- **技術挑戰**：如何卡住現有流程並插入自定義表演
- **設計考量**：不破壞現有架構，利用既有系統

### 1.2 分析現有流程
1. BaseGame滾停 → `GAME_Game1RollCompleteCommand`
2. 進入Feature Selection → `GAME_Game1FeatureSelectionCommand`
3. 發送收集準備 → `ViewMediatorEvent.PREPARE_COLLECT_BALL`
4. 開始收集球分 → Ball收集動畫

**插入點識別**：在步驟3之前插入表演，延遲步驟3的執行

### 1.3 技術方案選擇
參考其他開發者的實作方法，採用Symbol特效系統：
- 利用現有的SymbolFX特效池
- 添加新的SymbolPerformType狀態
- 使用事件機制觸發表演
- 通過延遲機制控制流程

## 2. 需要了解的專案核心內容

### 2.1 符號特效系統 (SymbolFX System)

#### 2.1.1 SymbolPerformType枚舉
**檔案位置**：`assets/src/sgv3/vo/enum/Reel.ts:21-34`

```typescript
export enum SymbolPerformType {
    SHOW = 0,
    HIDE = 1,
    SHOW_ALL_WIN = 3,
    SHOW_LOOP_WIN = 4,
    // ...現有狀態
    SHOW_TARGERT_CREDIT_RESULT = 14
}
```

**用途**：定義符號可執行的各種表演類型，每個類型對應不同的動畫效果。

#### 2.1.2 SymbolFX特效類別
**檔案位置**：`assets/src/game/view/symbol/SymbolFXStateRegister.ts`

這是符號特效的核心實作，包含：
- 狀態註冊機制：根據SymbolId註冊對應的特效狀態
- UIViewStateBase基類：所有特效狀態的基礎類別
- 具體特效實作：如`SymbolFXShowState`、`SymbolFXBaseCreditUpdateState`等

**關鍵概念**：
```typescript
// 特效狀態基本結構
export class SymbolFXShowState extends UIViewStateBase {
    public effectId: number = SymbolPerformType.SHOW; // 對應的表演類型
    
    onPlay() {
        // 播放邏輯
    }
    
    onSkip() {
        // 跳過邏輯
    }
}
```

### 2.2 ReelView與Pool管理

#### 2.2.1 SymbolFX對象池
ReelView維護一個SymbolFX對象池，用於復用特效對象：
- 根據位置索引 `poolKey = y * 5 + x` 獲取對象
- 避免重複創建，提升性能
- 支援動態位置設定和特效播放

#### 2.2.2 ReelViewMediator事件處理
**檔案位置**：`assets/src/game/mediator/ReelViewMediator.ts`

負責：
- 監聽各種遊戲事件
- 調用ReelView的方法執行具體表演
- 管理符號特效的生命週期

### 2.3 事件系統與流程控制

#### 2.3.1 ViewMediatorEvent事件常數
**檔案位置**：`assets/src/sgv3/util/Constant.ts`

```typescript
export class ViewMediatorEvent {
    public static readonly PREPARE_COLLECT_BALL: string = 'prepareCollectBall';
    // 其他事件...
}
```

**作用**：統一管理遊戲中的各種事件常數，確保事件名稱的一致性。

#### 2.3.2 Command指令模式
- 每個遊戲狀態對應一個Command類別
- Command負責該狀態的業務邏輯處理
- 通過`sendNotification()`發送事件到其他組件

## 3. 專案中類似的製作方式範例

### 3.1 現有的分數球收集特效
**檔案位置**：`assets/src/game/view/symbol/SymbolFXStateRegister.ts:141-166`

```typescript
export class SymbolFXBaseCreditUpdateState extends UIViewStateBase {
    public effectId: number = SymbolPerformType.SHOW_BASE_CREDIT_COLLECT;

    onPlay() {
        if (this.content.animation) {
            this.content.animation.play('BeginEffect', () => this.playWin());
        }
    }

    playWin() {
        this.content.animation.play('PlayWin');
        this.onEffectFinished(); // 通知表演完成
    }
}
```

**學習重點**：
- 使用回調函數控制動畫序列
- 通過`onEffectFinished()`通知系統表演完成
- 可播放連續的動畫效果

### 3.2 符號贏分表演
**檔案位置**：`assets/src/game/view/symbol/SymbolFXStateRegister.ts:40-116`

```typescript
export class SymbolFXShowState extends UIViewStateBase {
    private tempTween: Tween<Node> | null = null;

    onPlay() {
        // 設定標籤文字和字體
        if (this.content.labelText) {
            this.content.labelText.string = String(this.content.credit);
        }
        
        // 播放動畫並設定完成回調
        this.tempTween = tween(this.content.node)
            .delay(2)
            .call(() => {
                this.onEffectFinished();
            })
            .start();
    }

    onSkip() {
        this.tempTween.stop();
        this.onEffectFinished();
    }
}
```

**學習重點**：
- 使用Cocos Creator的Tween系統製作動畫
- 支援跳過功能（onSkip）
- 妥善管理Tween對象避免記憶體洩漏

### 3.3 延遲執行機制範例
**檔案位置**：`assets/src/game/command/state/GAME_Game1RollCompleteCommand.ts:35-43`

```typescript
// 延遲收集球的表演
let delayTime: number = 0;
let ballCount = curRoundResult.extendInfoForbaseGameResult.ballCount;
if (ballCount >= 6 && this.isHitGrand == false) {
    delayTime = 2;
} else if (ballCount > 0) {
    delayTime = 0.1;
}
GlobalTimer.getInstance().registerTimer(this.timerKey, delayTime, this.endGame1RollComplete, this).start();
```

**學習重點**：
- 使用GlobalTimer進行延遲控制
- 根據條件設定不同的延遲時間
- Timer完成後執行回調函數

## 4. 我們的實作方法

### 4.1 第一步：新增表演狀態

**檔案位置**：`assets/src/sgv3/vo/enum/Reel.ts:34`
```typescript
export enum SymbolPerformType {
    // ...現有狀態
    SHOW_TARGERT_CREDIT_RESULT = 14, //升龍賞 C2 球 最終結果 表演
    BEFORE_COLLECT = 15 //練習2: 收集分數球前的表演
}
```

**目的**：為新的表演類型定義唯一標識符。

### 4.2 第二步：實作表演特效類別

**檔案位置**：`assets/src/game/view/symbol/SymbolFXStateRegister.ts`

#### A. 註冊新狀態
在第30行為C1符號註冊新的表演狀態：
```typescript
case SymbolId.C1:
    this.registerState(new SymbolFXShowState(this.content));
    this.registerState(new SymbolFXBaseCreditUpdateState(this.content));
    this.registerState(new SymbolFXBeforeCollectState(this.content)); // 新增
    break;
```

#### B. 實作表演類別（第232-280行）
```typescript
export class SymbolFXBeforeCollectState extends UIViewStateBase {
    private content: SymbolFXContent | null = null;
    private tempTween: Tween<Node> | null = null;

    public effectId: number = SymbolPerformType.BEFORE_COLLECT;

    constructor(content: SymbolFXContent) {
        super();
        this.content = content;
    }

    onPlay() {
        // 設定分數球標籤文字
        if (this.content.labelText) {
            this.content.labelText.font = this.content.isSpecialFont
                ? this.content.specialFont
                : this.content.baseFont;
            this.content.labelText.string = this.content.isOmniChannel
                ? String(this.content.credit)
                : String(BalanceUtil.formatBalanceWithExpressingUnits(this.content.credit));
        }

        // 播放縮放動畫表演 (簡單的強調動畫)
        const originalScale = this.content.node.scale.clone();
        const targetScale = new Vec3(originalScale.x * 1.2, originalScale.y * 1.2, originalScale.z);
        
        this.tempTween = tween(this.content.node)
            .to(0.3, { scale: targetScale })    // 放大
            .to(0.3, { scale: originalScale })  // 縮小
            .to(0.3, { scale: targetScale })    // 再放大
            .to(0.3, { scale: originalScale })  // 恢復原狀
            .call(() => {
                this.onEffectFinished();        // 通知完成
            })
            .start();
    }

    onSkip() {
        if (this.tempTween) {
            this.tempTween.stop();
        }
        this.onEffectFinished();
    }
}
```

**技術要點**：
- 繼承`UIViewStateBase`基類
- 使用`effectId`關聯表演類型
- 通過`onPlay()`實作表演邏輯
- 通過`onSkip()`支援跳過功能
- 使用`onEffectFinished()`通知系統表演完成

### 4.3 第三步：新增觸發事件

**檔案位置**：`assets/src/sgv3/util/Constant.ts:177`
```typescript
export class ViewMediatorEvent {
    // ...現有事件
    /** 練習2: 收集分數球前的表演 */
    public static readonly BEFORE_COLLECT_BALL: string = 'beforeCollectBall';
    public static readonly PREPARE_COLLECT_BALL: string = 'prepareCollectBall';
}
```

**目的**：定義新的事件常數，用於觸發分數球表演。

### 4.4 第四步：修改流程控制邏輯

**檔案位置**：`assets/src/game/command/state/GAME_Game1FeatureSelectionCommand.ts:15-29`

```typescript
public execute(notification: puremvc.INotification): void {
    this.gameDataProxy.hasSelectionResponse = false;
    
    // 練習2: 檢查是否需要播放分數球表演
    let ballCount = this.gameDataProxy.spinEventData.baseGameResult.extendInfoForbaseGameResult.ballCount;
    if (ballCount >= 6) {
        // 先觸發分數球表演
        this.sendNotification(ViewMediatorEvent.BEFORE_COLLECT_BALL);
        // 延遲發送PREPARE_COLLECT_BALL (表演時間約1.2秒)
        setTimeout(() => {
            this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
            this.endGame1FeatureSelection();
        }, 1200);
    } else {
        // 原有邏輯：直接發送PREPARE_COLLECT_BALL
        this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
        this.endGame1FeatureSelection();
    }
}
```

**關鍵技術點**：
- 條件判斷：只在`ballCount >= 6`時執行表演
- 事件順序：先發送`BEFORE_COLLECT_BALL`，後發送`PREPARE_COLLECT_BALL`
- 時間控制：使用`setTimeout`延遲1200毫秒（配合表演時長）
- 流程分支：保持原有邏輯不變，只在特定條件下插入新邏輯

### 4.5 第五步：ReelViewMediator事件處理

**檔案位置**：`assets/src/game/mediator/ReelViewMediator.ts`

#### A. 添加事件監聽（第87行）
```typescript
public listNotificationInterests(): Array<string> {
    return Array.from(new Set([
        // ...現有事件
        AfterReconnectionCommand.NAME,
        ViewMediatorEvent.BEFORE_COLLECT_BALL  // 新增
    ].concat(super.baseListNotificationInterests())));
}
```

#### B. 添加事件處理（第168-170行）
```typescript
public handleNotification(notification: puremvc.INotification): void {
    super.baseHandleNotification(notification);
    let name = notification.getName();
    switch (name) {
        // ...現有case
        case ViewMediatorEvent.BEFORE_COLLECT_BALL:
            this.playBeforeCollectBallAnimation();
            break;
    }
}
```

#### C. 實作表演邏輯（第707-727行）
```typescript
protected playBeforeCollectBallAnimation() {
    // 獲取BaseGame結果和分數球位置信息
    let ballHitInfo = this.gameDataProxy.spinEventData.baseGameResult.extendInfoForbaseGameResult;
    
    // 找出所有有分數球的位置
    for (let x = 0; x < ballHitInfo.ballScreenLabel.length; x++) {
        for (let y = 0; y < ballHitInfo.ballScreenLabel[x].length; y++) {
            if (ballHitInfo.ballScreenLabel[x][y] > 0) {
                // 創建SymbolInfo來標識分數球位置
                let symbolInfo: SymbolInfo = new SymbolInfo();
                symbolInfo.sid = SymbolId.C1; // 分數球的Symbol ID
                symbolInfo.x = x;
                symbolInfo.y = y;
                
                // 從pool中取出SymbolFX並播放BEFORE_COLLECT動畫
                this.reelView.createAnimSymbol(symbolInfo);
                this.reelView.showBeforeCollectBallAnimation(symbolInfo, this.reelDataProxy.symbolFeature[x][y]);
            }
        }
    }
}
```

**技術解析**：
- 遍歷盤面找出所有分數球位置
- 為每個分數球創建SymbolInfo對象
- 調用ReelView的方法播放表演動畫
- 利用現有的`symbolFeature`數據設定表演參數

### 4.6 第六步：ReelView支援方法

**檔案位置**：`assets/src/game/view/GAME_ReelView.ts:335-347`

```typescript
public showBeforeCollectBallAnimation(symbolInfo: SymbolInfo, featureInfo: SymbolPosData) {
    const self = this;
    let poolKey: number = symbolInfo.y * self.reelsList.length + symbolInfo.x;
    let anim: SymbolFX = self.animManager.pool.get(poolKey);

    if (anim) {
        anim.node.setWorldPosition(self.getSymbolPosition(symbolInfo.x, symbolInfo.y));
        anim.setInfo(symbolInfo.sid, featureInfo);
        anim.node.active = true;
        // 播放BEFORE_COLLECT表演動畫
        anim.play(SymbolPerformType.BEFORE_COLLECT);
    }
}
```

**技術要點**：
- 計算對象池索引：`poolKey = y * reelLength + x`
- 從對象池獲取SymbolFX對象
- 設定世界座標位置和符號信息
- 調用`play()`方法播放指定類型的表演

## 5. 卡住流程的實作原理

### 5.1 原始流程分析
```
BaseGame滾停 → GAME_Game1RollCompleteCommand
    ↓
GAME_Game1FeatureSelectionCommand.execute()
    ↓
sendNotification(PREPARE_COLLECT_BALL)  ← 原本立即執行
    ↓
BallHitViewMediator收到通知開始收集
```

### 5.2 修改後的流程
```
BaseGame滾停 → GAME_Game1RollCompleteCommand
    ↓
GAME_Game1FeatureSelectionCommand.execute()
    ↓
ballCount >= 6 ?
    ├─ YES → sendNotification(BEFORE_COLLECT_BALL)  ← 插入表演
    │          ↓
    │        setTimeout(1200ms)  ← 卡住流程
    │          ↓
    │        sendNotification(PREPARE_COLLECT_BALL)  ← 延遲執行
    │
    └─ NO → sendNotification(PREPARE_COLLECT_BALL)  ← 原有流程
```

### 5.3 卡住機制的技術實作

#### 關鍵程式碼解析：
```typescript
if (ballCount >= 6) {
    // 第一步：觸發表演
    this.sendNotification(ViewMediatorEvent.BEFORE_COLLECT_BALL);
    
    // 第二步：延遲原有流程
    setTimeout(() => {
        this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
        this.endGame1FeatureSelection();
    }, 1200);  // 卡住1.2秒
} else {
    // 原有流程：不卡住，直接執行
    this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
    this.endGame1FeatureSelection();
}
```

#### 設計優點：
1. **非入侵性**：不修改現有流程，只是延遲執行
2. **條件性**：只在需要時才卡住流程
3. **時間精確**：延遲時間與表演時長匹配
4. **向下相容**：不影響ballCount < 6的情況

## 6. 分數球表演的實作原理

### 6.1 符號覆蓋機制

#### 重要概念：
專案使用「符號覆蓋」而非「符號替換」：
- 原有盤面的symbol保持不變
- SymbolFX從對象池中取出，覆蓋在原symbol上方
- 表演完成後SymbolFX回收，原symbol重新顯示

#### 技術實作：
```typescript
// 從對象池獲取SymbolFX對象
let anim: SymbolFX = self.animManager.pool.get(poolKey);

// 設定位置（覆蓋在原symbol上方）
anim.node.setWorldPosition(self.getSymbolPosition(symbolInfo.x, symbolInfo.y));

// 設定符號信息（包含分數等資料）
anim.setInfo(symbolInfo.sid, featureInfo);

// 啟動並播放表演
anim.node.active = true;
anim.play(SymbolPerformType.BEFORE_COLLECT);
```

### 6.2 動畫設計思路

#### 縮放動畫實作：
```typescript
// 儲存原始縮放比例
const originalScale = this.content.node.scale.clone();
const targetScale = new Vec3(originalScale.x * 1.2, originalScale.y * 1.2, originalScale.z);

// 播放縮放動畫序列
this.tempTween = tween(this.content.node)
    .to(0.3, { scale: targetScale })    // 300ms放大到1.2倍
    .to(0.3, { scale: originalScale })  // 300ms縮小回原狀
    .to(0.3, { scale: targetScale })    // 300ms再次放大
    .to(0.3, { scale: originalScale })  // 300ms最終恢復
    .call(() => {
        this.onEffectFinished();        // 總計1200ms，通知完成
    })
    .start();
```

#### 設計考量：
- **視覺效果**：雙次縮放增強注意力吸引
- **時間控制**：總時長1200ms配合流程延遲
- **資源管理**：完成後正確回收Tween對象
- **跳過支援**：提供onSkip()方法支援加速

### 6.3 分數顯示處理

```typescript
if (this.content.labelText) {
    // 根據渠道類型選擇字體
    this.content.labelText.font = this.content.isSpecialFont
        ? this.content.specialFont
        : this.content.baseFont;
    
    // 根據渠道類型格式化數字顯示
    this.content.labelText.string = this.content.isOmniChannel
        ? String(this.content.credit)  // 全渠道：直接顯示數字
        : String(BalanceUtil.formatBalanceWithExpressingUnits(this.content.credit)); // 一般渠道：格式化顯示
}
```

**學習重點**：
- 專案支援多渠道顯示模式
- 不同渠道有不同的數字格式化需求
- 字體選擇也會根據特殊情況調整

## 7. 關鍵技術點深度解析

### 7.1 對象池(Pool)模式的應用

#### 為什麼使用對象池？
1. **性能考量**：避免頻繁創建/銷毀SymbolFX對象
2. **記憶體管理**：復用對象，減少GC壓力
3. **位置管理**：poolKey確保每個盤面位置有對應的特效對象

#### 對象池索引計算：
```typescript
// 5x3盤面的索引計算
let poolKey: number = symbolInfo.y * 5 + symbolInfo.x;

// 範例：
// 位置(0,0) → poolKey = 0*5 + 0 = 0
// 位置(1,2) → poolKey = 2*5 + 1 = 11
// 位置(4,2) → poolKey = 2*5 + 4 = 14
```

### 7.2 事件驅動架構的優勢

#### 解耦合設計：
- Command負責業務邏輯判斷
- Mediator負責視圖層表演
- 兩者通過事件通信，相互獨立

#### 擴展性考量：
- 新增事件類型不影響現有組件
- 可以有多個Mediator監聽同一事件
- 便於添加調試和日誌功能

### 7.3 狀態機模式的運用

#### UIViewStateBase基類設計：
```typescript
export abstract class UIViewStateBase {
    public abstract effectId: number;  // 狀態標識
    
    abstract onPlay(): void;    // 播放邏輯
    abstract onSkip(): void;    // 跳過邏輯
    
    protected onEffectFinished(): void {
        // 通知狀態機表演完成
    }
}
```

#### 狀態註冊與管理：
```typescript
// 根據符號類型註冊不同的狀態
switch (this.content.symbolType) {
    case SymbolId.C1:
        this.registerState(new SymbolFXShowState(this.content));
        this.registerState(new SymbolFXBaseCreditUpdateState(this.content));
        this.registerState(new SymbolFXBeforeCollectState(this.content)); // 新增
        break;
}
```

## 8. 學習重點與技術收穫

### 8.1 專案架構深度理解

#### 多層架構設計：
- **Command Layer**：業務邏輯控制
- **Mediator Layer**：視圖事件處理  
- **View Layer**：具體的視覺表現
- **Data Layer**：遊戲數據管理

#### 組件職責分工：
- **SymbolPerformType**：狀態定義
- **SymbolFXState**：表演實作
- **ReelViewMediator**：事件協調
- **GAME_ReelView**：視圖操作

### 8.2 設計模式的實際應用

#### 狀態模式 (State Pattern)：
- 每個SymbolFX狀態都是獨立的類別
- 支援狀態間的切換和管理
- 便於添加新的表演類型

#### 對象池模式 (Object Pool Pattern)：
- 預先創建SymbolFX對象避免運行時開銷
- 通過poolKey索引快速獲取對象
- 自動管理對象的生命週期

#### 觀察者模式 (Observer Pattern)：
- 事件系統實現組件間的鬆耦合通信
- Command發送通知，Mediator接收處理
- 支援一對多的事件訂閱

### 8.3 Cocos Creator開發技巧

#### Tween動畫系統：
```typescript
// 鏈式調用創建複雜動畫序列
tween(node)
    .to(duration, properties)
    .delay(time)
    .call(callback)
    .start();
```

#### 座標系統管理：
```typescript
// 世界座標 vs 本地座標
anim.node.setWorldPosition(worldPos);  // 設定世界座標
anim.node.setPosition(localPos);       // 設定本地座標
```

#### 節點生命週期：
```typescript
// 正確的激活/停用順序
anim.node.active = true;   // 激活節點
anim.play(effectType);     // 播放動畫
// ... 動畫完成後自動處理回收
```

### 8.4 遊戲開發最佳實踐

#### 時間同步設計：
- 表演時間(1200ms) = 延遲時間(1200ms)
- 確保表演完成與流程恢復的精確同步
- 提供跳過功能應對快速操作需求

#### 條件判斷策略：
- 只在必要時執行表演邏輯
- 保持原有流程的穩定性
- 支援多種遊戲模式的兼容

#### 資源管理原則：
- 及時清理Tween對象避免記憶體洩漏
- 合理使用對象池提升性能
- 正確處理異常情況和邊界條件

## 9. 可能的擴展與優化方向

### 9.1 表演效果增強

#### 多樣化動畫效果：
- 旋轉動畫：`tween().by(duration, { angle: 360 })`
- 彈跳效果：使用緩動函數`easing.bounceOut()`
- 粒子特效：整合Particle System

#### 音效同步：
```typescript
onPlay() {
    // 播放音效
    AudioManager.Instance.play(AudioClipsEnum.Ball_Highlight);
    
    // 動畫與音效同步
    this.tempTween = tween(this.content.node)
        .to(0.3, { scale: targetScale })
        .call(() => {
            AudioManager.Instance.play(AudioClipsEnum.Ball_Scale);
        })
        .to(0.3, { scale: originalScale })
        .start();
}
```

### 9.2 性能優化策略

#### 批量處理優化：
```typescript
// 將所有分數球的表演合併為一個Timeline
protected playBeforeCollectBallAnimation() {
    let animPromises = [];
    
    for (let x = 0; x < ballHitInfo.ballScreenLabel.length; x++) {
        for (let y = 0; y < ballHitInfo.ballScreenLabel[x].length; y++) {
            if (ballHitInfo.ballScreenLabel[x][y] > 0) {
                animPromises.push(this.playBallAnimation(x, y));
            }
        }
    }
    
    // 所有動畫完成後統一通知
    Promise.all(animPromises).then(() => {
        this.onAllAnimationsComplete();
    });
}
```

#### 時間控制精確化：
```typescript
// 使用GlobalTimer替代setTimeout獲得更精確的控制
GlobalTimer.getInstance().registerTimer('beforeCollectDelay', 1.2, () => {
    this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
    this.endGame1FeatureSelection();
}, this).start();
```

### 9.3 用戶體驗改善

#### 加速跳過功能：
```typescript
// 監聽用戶操作跳過表演
public onUserSkipRequested() {
    // 立即停止所有表演
    this.skipAllBallAnimations();
    
    // 立即執行後續流程
    this.sendNotification(ViewMediatorEvent.PREPARE_COLLECT_BALL);
    this.endGame1FeatureSelection();
}
```

#### 視覺回饋增強：
```typescript
// 添加表演進度提示
onPlay() {
    // 顯示進度條或計數器
    this.showProgressIndicator(1200); // 顯示1.2秒的進度
    
    // 原有動畫邏輯...
}
```

## 10. 測試與驗證方案

### 10.1 功能測試checklist

- [ ] ballCount < 6時流程正常（無表演）
- [ ] ballCount >= 6時正確觸發表演
- [ ] 表演動畫效果符合預期
- [ ] 表演完成後收集流程正常繼續
- [ ] 跳過功能正常工作
- [ ] 不同分數值的顯示正確

### 10.2 邊界條件測試

- [ ] ballCount = 6的邊界情況
- [ ] 極大ballCount值的處理
- [ ] 快速連續操作的穩定性
- [ ] 記憶體使用情況監控

### 10.3 兼容性測試

- [ ] 不同裝置型號的表現
- [ ] 不同解析度下的顯示效果
- [ ] 與現有功能的交互正常

## 總結

題目二的實作體現了現代遊戲開發中的幾個重要概念：

1. **模組化設計**：每個組件職責明確，相互獨立
2. **事件驅動**：通過事件實現鬆耦合的組件通信  
3. **狀態管理**：使用狀態模式管理複雜的表演邏輯
4. **性能優化**：對象池、資源復用等技術的應用
5. **用戶體驗**：平滑的動畫過渡和跳過功能

通過這個練習，您可以深入了解一個成熟的遊戲專案是如何組織代碼、管理狀態、處理用戶交互的。這些知識不僅適用於Cocos Creator開發，也是通用的軟體工程最佳實踐。