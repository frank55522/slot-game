# 練習3 實作指南

## 題目描述

### 題目1：在播放滾分音效時淡出或暫停播放BGM，直到滾分結束
### 題目2：製作一個物件，並使用LocalizedLabel讓物件在畫面上根據不同語系表現出不同的結果
### 題目3：把M字獎的symbol連線表演改成播放動畫(可參考wild)，動畫自訂

---

## 題目1 實作指南：滾分時BGM淡出功能

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：在滾分音效播放期間，將背景音樂淡出，避免音效互相干擾
- **觸發條件**：滾分音效開始播放時
- **結束條件**：滾分表演完成時
- **影響範圍**：主遊戲(Game_1)滾分、免費遊戲(Game_2)滾分、特色遊戲結束後總贏分滾分

#### 1.2 技術思考點
1. 需要理解不同遊戲場景的BGM種類
2. 找到滾分音效播放的入口點和結束點
3. 利用AudioManager現有的淡入淡出功能
4. 確保不影響原有的滾分音效邏輯
5. **重要發現**：Game_4(昇龍賞)本身沒有滾分，滾分只在離開後回到Game_1時發生

### 2. 專案架構理解

#### 2.1 滾分系統分析

**滾分處理核心文件**：`assets/src/sgv3/command/byGame/ScoringHandleCommand.ts`

#### 滾分流程時序
```
handleScoring() -> playScoring() -> 滾分表演 -> runComplete() -> playScoringEnd()
     ↓              ↓                ↓              ↓              ↓
   設置數據        播放音效        進行滾分        表演結束        停止音效
```

#### 2.2 BGM系統分析

**不同場景的BGM類型**：
- **Game_1 (主遊戲)**：`BGM_Base` - 主遊戲背景音樂
- **Game_2 (免費遊戲)**：`BGM_FreeGame` - 免費旋轉背景音樂
- **Game_4 (昇龍賞)**：`BGM_DragonUp` - 但Game_4中不會觸發滾分！

**AudioManager的淡入淡出功能**：
```typescript
// 淡出到0音量，耗時0.5秒
AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, 0, 0.5);

// 淡入到1音量，耗時1.0秒
AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, 1, 1.0);
```

### 3. 詳細實作步驟

#### 步驟1：添加BGM枚舉導入

**檔案位置**：`assets/src/sgv3/command/byGame/ScoringHandleCommand.ts`

**修改內容**：
```typescript
// 修改前
import { ScoringClipsEnum } from '../../../game/vo/enum/SoundMap';

// 修改後
import { ScoringClipsEnum, BGMClipsEnum } from '../../../game/vo/enum/SoundMap';
```

#### 步驟2：在滾分開始前添加BGM淡出

**修改位置**：`ScoringHandleCommand.ts` 第78-91行

**修改內容**：
```typescript
GlobalTimer.getInstance()
    .registerTimer(
        this.timerKey_Sound,
        delayTime,
        () => {
            // 滾分開始前淡出BGM
            this.fadeBGMForScoring(0, 0.5);
            this.playScoring(this.finalWinType);
            this.playScoringVocal(this.finalWinType);
            this.setScoringData(startAmount, targetAmount, winBoardTargetAmount);
        },
        this
    )
    .start();
```

**關鍵改動**：在第84行添加 `this.fadeBGMForScoring(0, 0.5);`

#### 步驟3：在滾分結束後添加BGM恢復

**修改位置**：`ScoringHandleCommand.ts` 第123-132行

**修改內容**：
```typescript
// 表演結束
protected runComplete(isForceComplete: boolean) {
    this.playScoringEnd(isForceComplete);
    // 滾分結束後恢復BGM
    this.fadeBGMForScoring(1, 1.0);
    this.sendNotification(WinEvent.RUN_WIN_LABEL_COMPLETE, {
        targetAmount: this.finalWinAmount,
        winBoardTargetAmount: this.finalWinBoardAmount,
        winType: this.finalWinType
    });
}
```

**關鍵改動**：在第126行添加 `this.fadeBGMForScoring(1, 1.0);`

#### 步驟4：實作BGM控制方法

**添加位置**：`ScoringHandleCommand.ts` 第266-283行

**新增方法**：
```typescript
/**
 * 根據遊戲場景淡入淡出BGM
 * @param volume 目標音量 (0-1)
 * @param duration 淡入淡出時間
 */
private fadeBGMForScoring(volume: number, duration: number) {
    switch (this.gameDataProxy.curScene) {
        case GameScene.Game_1:
            AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, volume, duration);
            break;
        case GameScene.Game_2:
            AudioManager.Instance.fade(BGMClipsEnum.BGM_FreeGame, volume, duration);
            break;
        // Game_4 (昇龍賞) 中不會觸發滾分，滾分只在回到 Game_1 時發生
        // 所以不需要處理 Game_4 的 BGM
    }
}
```

### 4. 實作邏輯說明

#### 4.1 滾分觸發場景分析
1. **Game_1（主遊戲）**：普通中獎滾分 - 控制 `BGM_Base`
2. **Game_2（免費遊戲）**：免費旋轉中獎滾分 - 控制 `BGM_FreeGame`
3. **afterFeatureGame = true**：特色遊戲結束後回到 Game_1 的總贏分滾分 - 控制 `BGM_Base`

#### 4.2 Game_4特殊性
- **Game_4本身沒有滾分**：只有龍珠收集和數值顯示
- **滾分發生在離開後**：回到Game_1時才會進行總贏分滾分
- **不需要處理BGM_DragonUp**：因為滾分時已經回到Game_1，使用的是BGM_Base

#### 4.3 音效控制時序
```
滾分開始
    ↓
BGM淡出 (0.5秒內音量從1→0)
    ↓
播放滾分音效
    ↓
進行滾分表演
    ↓
滾分結束
    ↓
BGM淡入 (1.0秒內音量從0→1)
```

### 5. 實作完成效果

- **滾分開始時**：BGM在0.5秒內平滑淡出到靜音
- **滾分進行中**：只有滾分音效，沒有BGM干擾
- **滾分結束時**：BGM在1秒內平滑淡入恢復
- **無副作用**：不影響原有的滾分音效和表演邏輯
- **場景適應**：自動根據當前遊戲場景控制對應的BGM

### 6. 檔案修改總結

**修改檔案**：`E:\Github\slot-game\assets\src\sgv3\command\byGame\ScoringHandleCommand.ts`

**修改行數**：
- 第2行：添加BGMClipsEnum導入
- 第84行：添加滾分開始前BGM淡出
- 第126行：添加滾分結束後BGM恢復  
- 第271-283行：新增fadeBGMForScoring方法

**代碼行數增加**：約15行

---

## 題目2 實作指南：LocalizedLabel多語系顯示

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：創建一個使用LocalizedLabel的物件，根據不同語系顯示不同的文字內容
- **多語系支援**：支援英文(en)、中文(zh)、泰文(th)三種語言
- **顯示層級**：確保Label在最上層，不被其他UI元件遮蔽

#### 1.2 多語系系統分析
**語言資源檔案位置**：`assets/resources/i18n/`
- `en.ts` - 英文：`testText: 'Test Text'`
- `zh.ts` - 中文：`testText: '測試文字'`  
- `th.ts` - 泰文：`testText: 'ข้อความทดสอบ'`

### 2. 實作步驟

#### 步驟1：在Game_1.prefab中創建UI結構
**位置**：Game_1.prefab的根節點

**創建順序**：
1. 在根節點右鍵 → Create → 2D → Canvas
2. 在新建的Canvas下右鍵 → Create → 2D → Label
3. **重要**：刪除Label創建時自動生成的Camera節點

#### 步驟2：配置Canvas設置
**Canvas組件配置**：
- **Align Canvas With Screen**：勾選（確保Canvas與螢幕對齊）
- **Content Size**：設定合適的解析度（如圖中的1800 x 900）

**注意**：Cocos Creator的Canvas組件沒有Screen Space - Overlay和Priority設定，這些是Unity的概念

#### 步驟3：配置Label的LocalizedLabel組件
**Label組件基本設置**：
- **String**：預設文字（可留空，由LocalizedLabel控制）
- **Font**：選擇合適的字體

**LocalizedLabel組件設置**：
- **Data Key**：設定為 `testText`
- **Update Immediately**：勾選

#### 步驟4：語系切換測試
**語系設定方法**：在uiv3_api.js中修改語言設定，或透過遊戲內的語言切換功能

### 3. Camera問題解析

#### 3.1 為什麼會產生第二個Camera？
當在Cocos Creator中創建Label時，系統會自動創建一個Camera節點，這是因為：
- Label屬於UI組件，需要Camera來進行渲染
- 系統預設每個UI元件都需要獨立的相機

#### 3.2 為什麼刪除Camera後還能正常顯示？
- **Canvas自動渲染**：Cocos Creator的Canvas會自動使用場景中現有的UI Camera進行渲染
- **繼承渲染系統**：Canvas會繼承遊戲場景的渲染設定
- **UI層級系統**：Cocos Creator有內建的UI層級管理，不需要額外的Camera來控制顯示順序

#### 3.3 重疊畫面的原因和解決方案
**重疊問題的成因**：
- 原有的遊戲Camera渲染3D場景和UI
- 新增的Label Camera再次渲染相同內容，造成畫面重疊

**解決方案（擇一即可）**：
1. **直接刪除Camera**：最簡潔的方法，Canvas會自動使用場景Camera
2. **設定Camera Visibility為Nothing**：停用Camera的渲染功能
3. **取消勾選Camera組件**：停用Camera但保留節點結構

### 4. 最佳實作建議

#### 4.1 UI層級管理
```
Game_1 (根節點)
├── 遊戲3D內容
├── UI元件
└── Canvas (Screen Space - Overlay, 高Priority)
    └── Label (LocalizedLabel)
```

#### 4.2 顯示層級確保
- **Canvas配置**：勾選"Align Canvas With Screen"確保正確對齊
- **UI層級**：Cocos Creator會自動管理UI元素的顯示順序
- **Camera管理**：避免創建不必要的Camera節點，或適當設定其Visibility

### 5. 實作完成效果

- **多語系切換**：根據uiv3_api.js的語言設定顯示對應文字
- **正確顯示層級**：Label始終在最上層，不被遊戲元素遮蔽
- **無重疊畫面**：單一相機渲染，避免畫面重複問題
- **即時更新**：語言切換後立即更新顯示內容

---

## 題目3 實作指南：M符號連線動畫表演

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：將M字獎(M1-M6)的連線表演從閃爍改為自訂動畫
- **參考對象**：WILD符號的TimelineTool動畫實作方式
- **動畫類型**：使用專案原有的TimelineTool系統
- **保持原有邏輯**：不影響WILD和SCATTER的現有表演

#### 1.2 Symbol系統架構分析

**M字獎包含的符號**：
- M1 (SymbolId: 2) - M6 (SymbolId: 7)
- 區別於字獎 (K, Q, J, 10, 9, A) 和特殊符號 (WILD, SCATTER)

**連線表演流程**：
1. **ShowAllReelsWin**：所有中獎符號一起表演
2. **ShowReelsWin**：逐條連線播放各自的表演

**原有M字獎表演**：使用 `SymbolPerformType.SHOW_LOOP_WIN` (閃爍效果)

### 2. 技術實作架構（使用TimelineTool方式）

#### 2.1 在Game_1_SymbolContent添加TimelineTool支援
**檔案**：`assets/src/game/view/symbol/Game_1_SymbolContent.ts`

**添加TimelineTool導入和屬性**：
```typescript
import { TimelineTool } from 'TimelineTool';

@ccclass('Game_1_SymbolContent')
export class Game_1_SymbolContent extends SymbolContentBase {
    // ... 其他屬性
    @property({ type: TimelineTool, visible: true })
    public timelineTool: TimelineTool | null = null;
}
```

#### 2.2 創建繼承的State類別
**檔案**：`assets/src/game/view/symbol/Game_1_SymbolStateRegister.ts`

**新增兩個繼承類別**：
```typescript
import {
    SymbolAllWinState,
    SymbolLoopWinState,
    // ... 其他導入
} from '../../../sgv3/view/reel/symbol/SymbolStateRegisterBase';

export class Game_1_SymbolAllWinState extends SymbolAllWinState {
    private content: Game_1_SymbolContent | null = null;

    constructor(content: Game_1_SymbolContent) {
        super(content);
        this.content = content;
    }

    onPlay() {
        // 如果是M字獎(M1-M6)且有TimelineTool，則播放動畫
        if (this.content.symbolData.id >= SymbolId.M1 &&
            this.content.symbolData.id <= SymbolId.M6 &&
            this.content.timelineTool) {
            this.content.timelineTool.play('MPulseAllWin', () => {
                this.onEffectFinished();
            });
        } else {
            // 其他符號使用原有邏輯
            super.onPlay();
        }
    }

    onStop() {
        if (this.content.symbolData.id >= SymbolId.M1 &&
            this.content.symbolData.id <= SymbolId.M6 &&
            this.content.timelineTool) {
            this.content.timelineTool.stop();
            this.onEffectFinished(true);
        } else {
            super.onStop();
        }
    }

    onSkip() {
        if (this.content.symbolData.id >= SymbolId.M1 &&
            this.content.symbolData.id <= SymbolId.M6 &&
            this.content.timelineTool) {
            this.content.timelineTool.stop();
            this.onEffectFinished(true);
        } else {
            super.onSkip();
        }
    }
}

export class Game_1_SymbolLoopWinState extends SymbolLoopWinState {
    // 類似的實作，但使用 'MPulseLoopWin' 動畫
}
```

#### 2.3 註冊新的State類別
**在onRegister方法中註冊**：
```typescript
onRegister() {
    super.onRegister();
    // ... 其他註冊
    this.registerState(new Game_1_SymbolAllWinState(this.content));
    this.registerState(new Game_1_SymbolLoopWinState(this.content));
}
```

### 3. Cocos Creator中的TimelineTool配置

#### 3.1 在Game_1_Symbol Prefab中配置
1. **添加TimelineTool組件**：
   - 打開Game_1_Symbol.prefab
   - 在根節點添加TimelineTool組件

2. **為Main節點創建Animation**：
   - 選擇Main節點（實際顯示Symbol圖像的節點）
   - 添加Animation組件
   - 創建AnimationClip：`MPulseAllWin` 和 `MPulseLoopWin`

3. **設定動畫效果**：
   - **動畫時長**：約0.8秒
   - **縮放效果**：1.0 → 1.15 → 1.0 (兩次脈衝)
   - **作用對象**：Main節點的scale屬性

4. **連接TimelineTool**：
   - 在TimelineTool中創建兩個Timeline：
     - `MPulseAllWin`：AllWin階段使用
     - `MPulseLoopWin`：LoopWin階段使用
   - 將Main節點的Animation組件連接到TimelineTool

5. **連接到SymbolContent**：
   - 在Game_1_SymbolContent的timelineTool欄位
   - 將根節點的TimelineTool組件拖入此欄位

### 4. 連線表演流程

#### 4.1 完整表演流程
1. **第一階段** (ShowAllReelsWin)：
   - M字獎：播放 `MPulseAllWin` Timeline動畫
   - 其他符號：原本閃爍效果

2. **第二階段** (ShowReelsWin - 逐條連線)：
   - M字獎：播放 `MPulseLoopWin` Timeline動畫
   - WILD/SCATTER：原有TimelineTool動畫 (保持不變)
   - 其他符號：閃爍效果 (保持不變)

#### 4.2 技術優勢
- **使用專案原有架構**：符合團隊開發規範
- **易於維護**：Timeline動畫可視化編輯
- **擴展性佳**：可輕鬆添加更複雜的動畫效果
- **效能優化**：利用Cocos Creator的動畫系統

### 5. 實作檔案總結

**修改的檔案**：
1. `assets/src/game/view/symbol/Game_1_SymbolContent.ts`
   - 添加TimelineTool導入和屬性

2. `assets/src/game/view/symbol/Game_1_SymbolStateRegister.ts`
   - 新增Game_1_SymbolAllWinState類別
   - 新增Game_1_SymbolLoopWinState類別
   - 註冊新的State類別

3. **Cocos Creator Prefab配置**：
   - Game_1_Symbol.prefab：添加TimelineTool組件
   - 配置Timeline動畫：MPulseAllWin、MPulseLoopWin

**代碼增量**：約80行

### 6. 實作完成效果

- **M字獎連線表演**：播放TimelineTool縮放動畫，取代原本的閃爍效果
- **動畫流暢性**：使用Cocos Creator動畫系統，效果流暢
- **系統穩定性**：完整的stop/skip機制，支援快速跳過
- **架構一致性**：使用專案原有的TimelineTool系統
- **可維護性**：Timeline動畫可視化編輯，易於調整