# 練習3 實作指南

## 題目描述

### 題目1：在播放滾分音效時淡出或暫停播放BGM，直到滾分結束
### 題目2：製作一個物件，並使用LocalizedLabel讓物件在畫面上根據不同語系表現出不同的結果
### 題目3：把M字獎的symbol連線表演改成播放動畫(可參考wild)，動畫自訂

---

## 題目1 實作指南：滾分時BGM淡出功能

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：在滾分音效播放期間，將背景音樂淡出，避免音效互相干擾
- **觸發條件**：滾分音效開始播放時
- **結束條件**：滾分表演完成時
- **影響範圍**：主遊戲(Game_1)滾分、免費遊戲(Game_2)滾分、特色遊戲結束後總贏分滾分

#### 1.2 技術思考點
1. 需要理解不同遊戲場景的BGM種類
2. 找到滾分音效播放的入口點和結束點
3. 利用AudioManager現有的淡入淡出功能
4. 確保不影響原有的滾分音效邏輯
5. **重要發現**：Game_4(昇龍賞)本身沒有滾分，滾分只在離開後回到Game_1時發生

### 2. 專案架構理解

#### 2.1 滾分系統分析

**滾分處理核心文件**：`assets/src/sgv3/command/byGame/ScoringHandleCommand.ts`

#### 滾分流程時序
```
handleScoring() -> playScoring() -> 滾分表演 -> runComplete() -> playScoringEnd()
     ↓              ↓                ↓              ↓              ↓
   設置數據        播放音效        進行滾分        表演結束        停止音效
```

#### 2.2 BGM系統分析

**不同場景的BGM類型**：
- **Game_1 (主遊戲)**：`BGM_Base` - 主遊戲背景音樂
- **Game_2 (免費遊戲)**：`BGM_FreeGame` - 免費旋轉背景音樂
- **Game_4 (昇龍賞)**：`BGM_DragonUp` - 但Game_4中不會觸發滾分！

**AudioManager的淡入淡出功能**：
```typescript
// 淡出到0音量，耗時0.5秒
AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, 0, 0.5);

// 淡入到1音量，耗時1.0秒
AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, 1, 1.0);
```

### 3. 詳細實作步驟

#### 步驟1：添加BGM枚舉導入

**檔案位置**：`assets/src/sgv3/command/byGame/ScoringHandleCommand.ts`

**修改內容**：
```typescript
// 修改前
import { ScoringClipsEnum } from '../../../game/vo/enum/SoundMap';

// 修改後
import { ScoringClipsEnum, BGMClipsEnum } from '../../../game/vo/enum/SoundMap';
```

#### 步驟2：在滾分開始前添加BGM淡出

**修改位置**：`ScoringHandleCommand.ts` 第78-91行

**修改內容**：
```typescript
GlobalTimer.getInstance()
    .registerTimer(
        this.timerKey_Sound,
        delayTime,
        () => {
            // 滾分開始前淡出BGM
            this.fadeBGMForScoring(0, 0.5);
            this.playScoring(this.finalWinType);
            this.playScoringVocal(this.finalWinType);
            this.setScoringData(startAmount, targetAmount, winBoardTargetAmount);
        },
        this
    )
    .start();
```

**關鍵改動**：在第84行添加 `this.fadeBGMForScoring(0, 0.5);`

#### 步驟3：在滾分結束後添加BGM恢復

**修改位置**：`ScoringHandleCommand.ts` 第123-132行

**修改內容**：
```typescript
// 表演結束
protected runComplete(isForceComplete: boolean) {
    this.playScoringEnd(isForceComplete);
    // 滾分結束後恢復BGM
    this.fadeBGMForScoring(1, 1.0);
    this.sendNotification(WinEvent.RUN_WIN_LABEL_COMPLETE, {
        targetAmount: this.finalWinAmount,
        winBoardTargetAmount: this.finalWinBoardAmount,
        winType: this.finalWinType
    });
}
```

**關鍵改動**：在第126行添加 `this.fadeBGMForScoring(1, 1.0);`

#### 步驟4：實作BGM控制方法

**添加位置**：`ScoringHandleCommand.ts` 第266-283行

**新增方法**：
```typescript
/**
 * 根據遊戲場景淡入淡出BGM
 * @param volume 目標音量 (0-1)
 * @param duration 淡入淡出時間
 */
private fadeBGMForScoring(volume: number, duration: number) {
    switch (this.gameDataProxy.curScene) {
        case GameScene.Game_1:
            AudioManager.Instance.fade(BGMClipsEnum.BGM_Base, volume, duration);
            break;
        case GameScene.Game_2:
            AudioManager.Instance.fade(BGMClipsEnum.BGM_FreeGame, volume, duration);
            break;
        // Game_4 (昇龍賞) 中不會觸發滾分，滾分只在回到 Game_1 時發生
        // 所以不需要處理 Game_4 的 BGM
    }
}
```

### 4. 實作邏輯說明

#### 4.1 滾分觸發場景分析
1. **Game_1（主遊戲）**：普通中獎滾分 - 控制 `BGM_Base`
2. **Game_2（免費遊戲）**：免費旋轉中獎滾分 - 控制 `BGM_FreeGame`
3. **afterFeatureGame = true**：特色遊戲結束後回到 Game_1 的總贏分滾分 - 控制 `BGM_Base`

#### 4.2 Game_4特殊性
- **Game_4本身沒有滾分**：只有龍珠收集和數值顯示
- **滾分發生在離開後**：回到Game_1時才會進行總贏分滾分
- **不需要處理BGM_DragonUp**：因為滾分時已經回到Game_1，使用的是BGM_Base

#### 4.3 音效控制時序
```
滾分開始
    ↓
BGM淡出 (0.5秒內音量從1→0)
    ↓
播放滾分音效
    ↓
進行滾分表演
    ↓
滾分結束
    ↓
BGM淡入 (1.0秒內音量從0→1)
```

### 5. 實作完成效果

- **滾分開始時**：BGM在0.5秒內平滑淡出到靜音
- **滾分進行中**：只有滾分音效，沒有BGM干擾
- **滾分結束時**：BGM在1秒內平滑淡入恢復
- **無副作用**：不影響原有的滾分音效和表演邏輯
- **場景適應**：自動根據當前遊戲場景控制對應的BGM

### 6. 檔案修改總結

**修改檔案**：`E:\Github\slot-game\assets\src\sgv3\command\byGame\ScoringHandleCommand.ts`

**修改行數**：
- 第2行：添加BGMClipsEnum導入
- 第84行：添加滾分開始前BGM淡出
- 第126行：添加滾分結束後BGM恢復  
- 第271-283行：新增fadeBGMForScoring方法

**代碼行數增加**：約15行

---

## 題目2 實作指南：LocalizedLabel多語系顯示

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：創建一個使用LocalizedLabel的物件，根據不同語系顯示不同的文字內容
- **多語系支援**：支援英文(en)、中文(zh)、泰文(th)三種語言
- **顯示層級**：確保Label在最上層，不被其他UI元件遮蔽

#### 1.2 多語系系統分析
**語言資源檔案位置**：`assets/resources/i18n/`
- `en.ts` - 英文：`testText: 'Test Text'`
- `zh.ts` - 中文：`testText: '測試文字'`  
- `th.ts` - 泰文：`testText: 'ข้อความทดสอบ'`

### 2. 實作步驟

#### 步驟1：在Game_1.prefab中創建UI結構
**位置**：Game_1.prefab的根節點

**創建順序**：
1. 在根節點右鍵 → Create → 2D → Canvas
2. 在新建的Canvas下右鍵 → Create → 2D → Label
3. **重要**：刪除Label創建時自動生成的Camera節點

#### 步驟2：配置Canvas設置
**Canvas組件配置**：
- **Align Canvas With Screen**：勾選（確保Canvas與螢幕對齊）
- **Content Size**：設定合適的解析度（如圖中的1800 x 900）

**注意**：Cocos Creator的Canvas組件沒有Screen Space - Overlay和Priority設定，這些是Unity的概念

#### 步驟3：配置Label的LocalizedLabel組件
**Label組件基本設置**：
- **String**：預設文字（可留空，由LocalizedLabel控制）
- **Font**：選擇合適的字體

**LocalizedLabel組件設置**：
- **Data Key**：設定為 `testText`
- **Update Immediately**：勾選

#### 步驟4：語系切換測試
**語系設定方法**：在uiv3_api.js中修改語言設定，或透過遊戲內的語言切換功能

### 3. Camera問題解析

#### 3.1 為什麼會產生第二個Camera？
當在Cocos Creator中創建Label時，系統會自動創建一個Camera節點，這是因為：
- Label屬於UI組件，需要Camera來進行渲染
- 系統預設每個UI元件都需要獨立的相機

#### 3.2 為什麼刪除Camera後還能正常顯示？
- **Canvas自動渲染**：Cocos Creator的Canvas會自動使用場景中現有的UI Camera進行渲染
- **繼承渲染系統**：Canvas會繼承遊戲場景的渲染設定
- **UI層級系統**：Cocos Creator有內建的UI層級管理，不需要額外的Camera來控制顯示順序

#### 3.3 重疊畫面的原因和解決方案
**重疊問題的成因**：
- 原有的遊戲Camera渲染3D場景和UI
- 新增的Label Camera再次渲染相同內容，造成畫面重疊

**解決方案（擇一即可）**：
1. **直接刪除Camera**：最簡潔的方法，Canvas會自動使用場景Camera
2. **設定Camera Visibility為Nothing**：停用Camera的渲染功能
3. **取消勾選Camera組件**：停用Camera但保留節點結構

### 4. 最佳實作建議

#### 4.1 UI層級管理
```
Game_1 (根節點)
├── 遊戲3D內容
├── UI元件
└── Canvas (Screen Space - Overlay, 高Priority)
    └── Label (LocalizedLabel)
```

#### 4.2 顯示層級確保
- **Canvas配置**：勾選"Align Canvas With Screen"確保正確對齊
- **UI層級**：Cocos Creator會自動管理UI元素的顯示順序
- **Camera管理**：避免創建不必要的Camera節點，或適當設定其Visibility

### 5. 實作完成效果

- **多語系切換**：根據uiv3_api.js的語言設定顯示對應文字
- **正確顯示層級**：Label始終在最上層，不被遊戲元素遮蔽
- **無重疊畫面**：單一相機渲染，避免畫面重複問題
- **即時更新**：語言切換後立即更新顯示內容

---

## 題目3 實作指南：M符號連線動畫表演

### 1. 實作前的思路構築

#### 1.1 問題分析
- **核心需求**：將M字獎(M1-M6)的連線表演從閃爍改為自訂的脈衝動畫
- **參考對象**：WILD符號的動畫實作方式
- **動畫類型**：使用tween製作簡單的脈衝效果
- **保持原有邏輯**：不影響WILD和SCATTER的現有表演

#### 1.2 Symbol系統架構分析

**M字獎包含的符號**：
- M1 (SymbolId: 2) - M6 (SymbolId: 7)
- 區別於字獎 (K, Q, J, 10, 9, A) 和特殊符號 (WILD, SCATTER)

**連線表演流程**：
1. **ShowAllReelsWin**：所有中獎符號一起閃爍
2. **ShowReelsWin**：逐條連線播放各自的表演

**原有M字獎表演**：使用 `SymbolPerformType.SHOW_LOOP_WIN` (閃爍效果)

### 2. 技術實作架構

#### 2.1 新增表演類型枚舉
**檔案**：`assets/src/sgv3/vo/enum/Reel.ts`

**修改內容**：
```typescript
export enum SymbolPerformType {
    // ... 現有類型
    SHOW_M_PULSE = 16 // M字獎脈衝動畫表演
}
```

#### 2.2 創建脈衝動畫類別
**檔案**：`assets/src/sgv3/view/reel/symbol/SymbolStateRegisterBase.ts`

**新增 SymbolMPulseState 類別**：
```typescript
export class SymbolMPulseState extends UIViewStateBase {
    public effectId: number = SymbolPerformType.SHOW_M_PULSE;
    
    onPlay() {
        // 脈衝動畫效果：兩次縮放脈衝
        this.symbolContent.tween = tween(this.symbolContent.mainSprite.node)
            .to(0.2, { scale: new Vec3(1.15, 1.15, 1) })    // 放大
            .to(0.2, { scale: new Vec3(1, 1, 1) })          // 縮小
            .to(0.2, { scale: new Vec3(1.15, 1.15, 1) })    // 再放大
            .to(0.2, { scale: new Vec3(1, 1, 1) })          // 再縮小
            .call(() => {
                this.onEffectFinished();
                this.symbolContent.tween = null;
            })
            .start();
    }
    
    // 完整的 onStop() 和 onSkip() 處理
}
```

#### 2.3 修改連線判斷邏輯
**檔案**：`assets/src/game/view/GAME_ReelView.ts`

**showLoopWinSymbol 方法修改**：
```typescript
public showLoopWinSymbol(symbolInfo: SymbolInfo, featureInfo: SymbolPosData) {
    switch (symbolInfo.sid) {
        case SymbolId.WILD:
        case SymbolId.C1:
            // WILD 和 SCATTER 保持原有動畫
            self.setAnimSymbolPlay(symbolInfo, featureInfo);
            self.setDefaultSymbolPlay(symbolInfo, SymbolPerformType.HIDE);
            break;
        case SymbolId.M1:
        case SymbolId.M2:
        case SymbolId.M3:
        case SymbolId.M4:
        case SymbolId.M5:
        case SymbolId.M6:
            // M字獎使用脈衝動畫
            self.setDefaultSymbolPlay(symbolInfo, SymbolPerformType.SHOW_M_PULSE);
            break;
        default:
            // 其他符號保持原有閃爍
            self.setDefaultSymbolPlay(symbolInfo, SymbolPerformType.SHOW_LOOP_WIN);
            break;
    }
}
```

### 3. 動畫效果設計

#### 3.1 脈衝動畫參數
- **動畫總時長**：0.8秒
- **脈衝次數**：2次完整的放大縮小循環
- **縮放比例**：1.0 ↔ 1.15 (15%的放大效果)
- **緩動時間**：每次變化0.2秒

#### 3.2 動畫時序
```
開始 → 放大(0.2s) → 縮小(0.2s) → 再放大(0.2s) → 再縮小(0.2s) → 結束
 1.0  →   1.15    →   1.0     →    1.15     →    1.0    → 完成
```

### 4. 連線表演流程

#### 4.1 完整表演流程
1. **第一階段** (ShowAllReelsWin)：
   - M字獎：原本閃爍效果 (保持與其他符號一致)
   - 其他符號：原本閃爍效果

2. **第二階段** (ShowReelsWin - 逐條連線)：
   - M字獎：**脈衝動畫** (新的自訂效果)
   - WILD/SCATTER：TimelineTool動畫 (保持不變)
   - 其他符號：閃爍效果 (保持不變)

#### 4.2 向後相容性
- **不影響現有表演**：WILD、SCATTER、字獎的動畫維持原樣
- **可擴充性**：新增表演類型不影響既有系統
- **錯誤處理**：完整的 stop/skip 機制

### 5. 實作檔案總結

**修改的檔案**：
1. `assets/src/sgv3/vo/enum/Reel.ts` (第35行)
   - 新增 `SHOW_M_PULSE = 16` 枚舉

2. `assets/src/sgv3/view/reel/symbol/SymbolStateRegisterBase.ts` (第24行, 198-256行)
   - 註冊 SymbolMPulseState 類別
   - 新增完整的脈衝動畫實作

3. `assets/src/game/view/GAME_ReelView.ts` (第187-193行)
   - 修改 M字獎的連線判斷邏輯

**代碼增量**：約70行

### 6. 實作完成效果

- **M字獎連線表演**：播放自訂的縮放脈衝動畫，取代原本的閃爍效果
- **動畫流暢性**：0.8秒完整週期，視覺效果自然
- **系統穩定性**：完整的停止/跳過機制，不會造成動畫卡頓
- **相容性佳**：不影響其他符號的現有表演
- **可維護性**：清晰的代碼結構，易於後續調整和擴展